{"config":{"lang":["ja"],"separator":"[\\s\\-\uff0c\u3002]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.</code></pre>"},{"location":"data_structure/","title":"\u6570\u636e\u7ed3\u6784","text":""},{"location":"data_structure/#\u6570\u636e\u7ed3\u6784","title":"\u6570\u636e\u7ed3\u6784","text":""},{"location":"data_structure/#\u7ebf\u6bb5\u6811","title":"\u7ebf\u6bb5\u6811","text":"<pre><code>// Luogu P3373\ntemplate&lt;typename T = int&gt;\ninline T read() {\n    T ret;\n    cin &gt;&gt; ret;\n    return ret;\n}\n\ntemplate&lt;class Fun&gt;\nclass Y_combinator {\nprivate:\n    Fun fun_;\npublic:\n    template&lt;class F&gt;\n    Y_combinator(F&amp;&amp; fun) : fun_(static_cast&lt;F&amp;&amp;&gt;(fun)) {}\n    template&lt;class... Args&gt;\n    decltype(auto) operator () (Args&amp;&amp;...args) const {\n        return fun_(*this, static_cast&lt;Args&amp;&amp;&gt;(args)...);\n    }\n};\ntemplate&lt;class T&gt; Y_combinator(T)-&gt;Y_combinator&lt;T&gt;;\n\n#define MID ((l + r) &gt;&gt; 1)\n#define LEFT (cur &lt;&lt; 1)\n#define RIGHT ((cur &lt;&lt; 1) | 1)\n\nint main(int argc, char* argv[]) {\n    fastIO();\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;ll&gt; arr{0};\n    for (int i = 0; i &lt; n; ++i) {\n        arr.push_back(read&lt;ll&gt;());\n    }\n    vector&lt;ll&gt; lazy((n &lt;&lt; 2) + 10);\n    vector&lt;ll&gt; node((n &lt;&lt; 2) + 10);\n    Y_combinator(\n        [&amp;](auto&amp;&amp; build, int cur, int l, int r) -&gt; void {\n            if (l == r) {\n                node[cur] = arr[l];\n            } else {\n                build(LEFT, l, MID);\n                build(RIGHT, MID + 1, r);\n                node[cur] = node[LEFT] + node[RIGHT];\n            }\n        }\n    )(1, 1, n);\n    auto&amp;&amp; lazyUpdate = [&amp;](int cur, int l, int r) -&gt; void {\n        if (lazy[cur] != 0) {\n            node[LEFT] += lazy[cur] * (MID - l + 1);\n            node[RIGHT] += lazy[cur] * (r - MID);\n            lazy[LEFT] += lazy[cur];\n            lazy[RIGHT] += lazy[cur];\n            lazy[cur] = 0;\n        }\n    };\n    auto&amp;&amp; update = Y_combinator(\n        [&amp;](auto&amp;&amp; update, int cur, int l, int r, int s, int e, ll v) {\n            if (s &gt; r or e &lt; l) return;\n            if (s &lt;= l and r &lt;= e) {\n                node[cur] += (r - l + 1) * v;\n                lazy[cur] += v;\n            } else {\n                lazyUpdate(cur, l, r);\n                update(LEFT, l, MID, s, e, v);\n                update(RIGHT, MID + 1, r, s, e, v);\n                node[cur] = node[LEFT] + node[RIGHT];\n            }\n        }\n    );\n    auto&amp;&amp; query = Y_combinator(\n        [&amp;](auto&amp;&amp; query, int cur, int l, int r, int s, int e)-&gt;ll {\n            if (s &gt; r or e &lt; l) return 0;\n            if (s &lt;= l and e &gt;= r) {\n                return node[cur];\n            }\n            lazyUpdate(cur, l, r);\n            ll ret = query(LEFT, l, MID, s, e);\n            ret += query(RIGHT, MID + 1, r, s, e);\n            return ret;\n        }\n    );\n    while (m--) {\n        int q, x, y, k;\n        cin &gt;&gt; q &gt;&gt; x &gt;&gt; y;\n        if (q == 1) {\n            cin &gt;&gt; k;\n            update(1, 1, n, x, y, k);\n        } else {\n            cout &lt;&lt; query(1, 1, n, x, y) &lt;&lt; endl;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"data_structure/#st\u8868\u7a00\u758f\u8868c17","title":"ST\u8868\uff08\u7a00\u758f\u8868\uff09(C++17)","text":"<pre><code>template&lt;typename iter, typename BinOp&gt;\nclass SparseTable {\n    using T = typename remove_reference&lt;decltype(*declval&lt;iter&gt;())&gt;::type;\n    vector&lt;vector&lt;T&gt;&gt; arr;\n    BinOp binOp;\npublic:\n    SparseTable(iter begin, iter end, BinOp binOp) : arr(1), binOp(binOp) {\n        int n = distance(begin, end);\n        arr.assign(32 - __builtin_clz(n), vector&lt;T&gt;(n));\n        arr[0].assign(begin, end);\n        for (int i = 1; i &lt; arr.size(); ++i) {\n            for (int j = 0; j &lt; n - (1 &lt;&lt; i) + 1; ++j) {\n                arr[i][j] = binOp(arr[i - 1][j], arr[i - 1][j + (1 &lt;&lt; (i - 1))]);\n            }\n        }\n    }\n    T query(int lPos, int rPos) {\n        int h = floor(log2(rPos - lPos + 1));\n        return binOp(arr[h][lPos], arr[h][rPos - (1 &lt;&lt; h) + 1]);\n    }\n};\n</code></pre>"},{"location":"data_structure/#\u6811\u72b6\u6570\u7ec4","title":"\u6811\u72b6\u6570\u7ec4","text":"<pre><code>template&lt;typename T&gt;\nstruct FenWick {\n    int N;\n    vector&lt;T&gt; arr;\n    FenWick(int sz): N(sz), arr(sz + 1, 0) {}\n    void update(int pos, T val) {\n        for (; pos &lt;= N;pos |= (pos + 1)) {\n            arr[pos] += val;\n        }\n    }\n    // \u83b7\u53d6 [1, pos] \u7684\u548c\n    T get(int pos) {\n        T ret = 0;\n        for (; pos &gt; 0; --pos) {\n            ret += arr[pos];\n            pos &amp;= (pos + 1);\n        }\n        return ret;\n    }\n    // \u83b7\u53d6 [l, r] \u7684\u548c\n    T query(int l, int r) {\n        return get(r) - get(l - 1);\n    }\n};\n</code></pre>"},{"location":"data_structure/#\u73c2\u6735\u8389\u6811","title":"\u73c2\u6735\u8389\u6811","text":"<pre><code>namespace Chtholly{\nstruct Node{\n    int l, r;\n    mutable int v;\n    Node(int il, int ir, int iv): l(il), r(ir), v(iv){}\n    bool operator &lt; (const Node&amp; arg) const{\n        return l &lt; arg.l;\n    }\n};\nclass Tree{\nprotected:\n    auto split(int pos){\n        if(pos &gt; _sz) return odt.end();\n        auto it = --odt.upper_bound(Node{pos, 0, 0});\n        if(it-&gt;l == pos) return it;\n        auto tmp = *it;\n        odt.erase(it);\n        odt.insert({tmp.l, pos - 1, tmp.v});\n        return odt.insert({pos, tmp.r, tmp.v}).first;\n    }  \npublic:\n    Tree(int sz, int ini = 1): _sz(sz), odt({Node{1, sz, ini}}) {}\n    virtual void assign(int l, int r, int v){\n        auto itr = split(r + 1), itl = split(l);\n        // operations here\n        odt.erase(itl, itr);\n        odt.insert({l, r, v});\n    }\nprotected:\n    int _sz;\n    set&lt;Node&gt; odt;\n};\n}\n\n</code></pre>"},{"location":"data_structure/#splay\u6811","title":"Splay\u6811","text":"<p>https://loj.ac/p/104 \u6709\u8bef\uff0c\u6682\u672a\u4fee</p> <pre><code>#include &lt;vector&gt;\n#include &lt;array&gt;\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\nusing namespace std;\ntemplate&lt;typename T&gt;\nclass SplayTree{\npublic:\n    struct Node{\n        Node *parent{};\n        std::array&lt;Node*, 2&gt; child{};\n        T val;\n        // cnt: repeat of current element, sz: element count of child tree, sum: repeats of child tree\n        size_t cnt, sz, sum;\n        explicit Node(T value_arg): val(value_arg), cnt(1), sz(1), sum(1){}\n        bool side() const{\n            return parent-&gt;child[1] == this;\n        }\n        // maintain information of current element\n        void maintain(){\n            if(!this) return;\n            this-&gt;sum = this-&gt;cnt;\n            this-&gt;sz = 1;\n            if(this-&gt;child[0]) {\n                this-&gt;sum += this-&gt;child[0]-&gt;sum;\n                this-&gt;sz += this-&gt;child[0]-&gt;sz;\n            }\n            if(this-&gt;child[1]) {\n                this-&gt;sum += this-&gt;child[1]-&gt;sum;\n                this-&gt;sz += this-&gt;child[1]-&gt;sz;\n            }\n        }\n        // left rotate and right rotate\n        void rotate(){\n            const auto p = parent;\n            const bool i = side();\n            if(p-&gt;parent){\n                p-&gt;parent-&gt;attach(p-&gt;side(), this);\n            }else{\n                parent = nullptr;\n            }\n            p-&gt;attach(i, child[!i]);\n            attach(!i, p);\n            p-&gt;maintain();\n            maintain();\n        }\n        void splay(){\n            for(;parent;rotate()){\n                if(parent-&gt;parent){\n                    (side() == parent-&gt;side() ? parent: this)-&gt;rotate();\n                }\n            }\n        }\n        // attach node new_ as the node's side child\n        void attach(bool side, Node* const new_){\n            if(new_) new_-&gt;parent = this;\n            child[side] = new_;\n        }\n    };\n    struct iterator{\n        using iterator_category = std::bidirectional_iterator_tag;\n        using value_type = T;\n        using pointer = T*;\n        using reference = T&amp;;\n        using difference_type = long long;\n    public:\n        Node* node;\n        void operator--(){ advance&lt;false&gt;();}\n        void operator++(){ advance&lt;true&gt;();}\n        const T&amp; operator*(){return node-&gt;val;}\n        explicit iterator(Node* node_arg): node(node_arg){}\n        bool operator==(const iterator oth) const{\n            return node == oth.node;\n        }\n        bool operator != (const iterator oth) const{\n            return *this != oth;\n        }\n    private:\n        template&lt;bool dir&gt; void advance(){\n            if(node-&gt;child[dir]){\n                node = extremum&lt;!dir&gt;(node-&gt;child[dir]);\n                return;\n            }\n            for(;node-&gt;parent and node-&gt;side() == dir; node = node-&gt;parent);\n            node = node-&gt;parent;\n        }\n    };\n\n    template&lt;bool i&gt; static Node* extremum(Node* x){\n        assert(x);\n        for(;x-&gt;child[i]; x = x-&gt;child[i]);\n        return x;\n    }\n    Node* rt{};\n    explicit SplayTree()= default;\n    ~SplayTree(){ destroy(rt);}\n    void insert(const T&amp; arg){\n        if(!rt){\n            rt = new Node(arg);\n            rt-&gt;maintain();\n            return;\n        }\n        Node* cur = rt, *f = nullptr;\n        while(true){\n            if(cur-&gt;val == arg){\n                cur-&gt;cnt++;\n                cur-&gt;maintain();\n                f-&gt;maintain();\n                cur-&gt;splay();\n                rt = cur;\n                break;\n            }\n            f = cur;\n            cur = cur-&gt;child[cur-&gt;val &lt; arg];\n            if(!cur){\n                Node* tmp = new Node(arg);\n                f-&gt;child[f-&gt;val &lt; arg] = tmp;\n                tmp-&gt;parent = f;\n                tmp-&gt;maintain();\n                f-&gt;maintain();\n                tmp-&gt;splay();\n                rt = tmp;\n                break;\n            }\n        }\n    }\n\n    // size, sum\n    std::pair&lt;size_t, size_t&gt; rank(const T&amp; arg){\n        std::pair&lt;size_t, size_t&gt; res{0, 0};\n        Node* cur = rt;\n        while(cur){\n            if(arg &lt; cur-&gt;val){\n                cur = cur-&gt;child[0];\n            }else{\n                if(cur-&gt;child[0]) {\n                    res.first += cur-&gt;child[0]-&gt;sz;\n                    res.second += cur-&gt;child[0]-&gt;sum;\n                }\n                res.first ++;\n                res.second += cur-&gt;cnt;\n                if(arg == cur-&gt;val){\n                    cur-&gt;splay();\n                    rt = cur;\n                    break;\n                }\n                cur = cur-&gt;child[1];\n            }\n        }\n        return res;\n    }\n    template&lt;bool unique = false&gt;\n    iterator kth(size_t k){\n        assert(k &lt;= (rt != nullptr ? (unique ? rt-&gt;sz : rt-&gt;sum) : 0));\n        Node* cur = rt;\n        while(true){\n            if(cur-&gt;child[0] and k &lt;= (unique ? cur-&gt;child[0]-&gt;sz : cur-&gt;child[0]-&gt;sum)){\n                cur = cur-&gt;child[0];\n            }else{\n                if(cur-&gt;child[0]) k -= (unique ? cur-&gt;child[0]-&gt;sz : cur-&gt;child[0]-&gt;sum);\n                if(k &lt;= cur-&gt;cnt){\n                    cur-&gt;splay();\n                    rt = cur;\n                    return iterator{cur};\n                }\n                k -= (unique ? 1 : cur-&gt;cnt);\n                cur = cur-&gt;child[1];\n            }\n        }\n    }\n    static void destroy(Node* const node){\n        if(!node) return;\n        for(Node* const child: node-&gt;child){\n            destroy(child);\n        }\n        delete node;\n    }\n    bool empty() const{\n        return rt == nullptr;\n    }\n    size_t sum() const{\n        return (rt == nullptr ? 0 : rt-&gt;sum);\n    }\n    size_t size() const{\n        return (rt == nullptr ? 0 : rt-&gt;sz);\n    }\n\n    template&lt;bool side = false&gt;\n    iterator begin(){\n        return iterator{extremum&lt;side&gt;(rt)};\n    }\n    iterator rend(){\n        return iterator{nullptr};\n    }\n    iterator end(){\n        return iterator{nullptr};\n    }\n    iterator find(const T&amp; key){\n        Node* cur = rt;\n        while(cur and key != cur-&gt;val){\n            const auto nex = cur-&gt;child[key &gt; cur-&gt;val];\n            if(!nex) {\n                cur-&gt;splay();\n                rt = cur;\n            }\n            cur = nex;\n        }\n        return iterator{cur};\n    }\n    iterator lower_bound(const T&amp; key){\n        Node* cur = rt;\n        Node* ret = nullptr;\n        while(cur){\n            if(cur-&gt;val &gt; key){\n                ret = cur;\n                cur = cur-&gt;child[0];\n            }else if(cur-&gt;val == key){\n                ret = cur;\n                break;\n            }else{\n                cur = cur-&gt;child[1];\n            }\n        }\n        if(ret){\n            ret-&gt;splay();\n            rt = ret;\n        }\n        return iterator{ret};\n    }\n    Node* join(Node* const arg1, Node* const arg2){\n        if(!arg1){\n            arg2-&gt;parent = nullptr;\n            return arg2;\n        }\n        arg1-&gt;parent = nullptr;\n        Node* const mx = extremum&lt;true&gt;(arg1);\n        mx-&gt;splay();\n        rt = mx;\n        assert(mx-&gt;child[1] == nullptr);\n        mx-&gt;child[1] = arg2;\n        mx-&gt;parent = nullptr;\n        if(arg2) arg2-&gt;parent = mx;\n        mx-&gt;maintain();\n        return mx;\n    }\n    void erase(const iterator itr){\n        if(!itr.node) return;\n        Node* x = itr.node;\n        x-&gt;splay();\n        rt = x;\n        rt = join(x-&gt;child[0], x-&gt;child[1]);\n    }\n    void extract(const iterator itr){\n        if(!itr.node) return;\n        if(itr.node-&gt;cnt == 1) erase(itr);\n        else{\n            itr.node-&gt;cnt--;\n            itr.node-&gt;splay();\n            rt = itr.node;\n        }\n    }\n};\ntypedef pair&lt;int, int&gt; PII;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    SplayTree&lt;int&gt; st;\n    int n;\n    cin &gt;&gt; n;\n    while(n--){\n        int op;\n        cin &gt;&gt; op;\n        if(op == 1){\n            int tv;\n            cin &gt;&gt; tv;\n            st.insert(tv);\n        }else if(op == 2){\n            int tv;\n            cin &gt;&gt; tv;\n            st.extract(st.find(tv));\n        }else if(op == 3){\n            int tv;\n            cin &gt;&gt; tv;\n            auto itr = st.find(tv);\n            auto res = st.rank(tv);\n            cout &lt;&lt; res.second - (itr.node-&gt;cnt) + 1 &lt;&lt; endl;\n        }else if(op == 4){\n            int tv;\n            cin &gt;&gt; tv;\n            auto itr = st.kth(tv);\n            cout &lt;&lt; itr.node-&gt;val &lt;&lt; endl;\n        }else if(op == 5){\n            int tv;\n            cin &gt;&gt; tv;\n            auto itr = st.lower_bound(tv);\n            if(itr == st.end()) itr = st.begin&lt;true&gt;();\n            else --itr;\n            cout &lt;&lt; itr.node-&gt;val &lt;&lt; endl;\n        }else{\n            int tv;\n            cin &gt;&gt; tv;\n            auto itr = st.lower_bound(tv);\n            if(itr.node-&gt;val == tv) ++itr;\n            cout &lt;&lt; itr.node-&gt;val &lt;&lt; endl;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"data_structure/#avl\u6811","title":"AVL\u6811","text":"<pre><code>/**\n * @brief AVL \u6811\n * @author dianhsu\n * @date 2021/05/25\n * @ref https://zh.wikipedia.org/wiki/AVL\u6811\n * */\n#include &lt;bits/stdc++.h&gt;\n\ntemplate&lt;class T&gt;\nstruct AVLNode {\n    T data;\n    AVLNode&lt;T&gt; *leftChild;\n    AVLNode&lt;T&gt; *rightChild;\n    int height;\n\n    AVLNode(T data): data(data), height(1), leftChild(nullptr), rightChild(nullptr) { }\n\n    ~AVLNode() {\n        delete leftChild;\n        delete rightChild;\n    }\n};\n\ntemplate&lt;class T&gt;\nclass AVL {\npublic:\n    AVL() {\n        root = nullptr;\n    }\n\n    ~AVL() {\n        delete root;\n    }\n\n    /**\n     * @brief \u5c06\u7ed3\u70b9\u63d2\u5165\u5230AVL\u6811\u4e2d\n     * @param val \u9700\u8981\u63d2\u5165\u7684\u503c\n     * @note \u5982\u679c\u53d1\u73b0\u8fd9\u4e2a\u6811\u4e2d\u5df2\u7ecf\u6709\u8fd9\u4e2a\u503c\u5b58\u5728\u4e86\uff0c\u5c31\u4e0d\u4f1a\u8fdb\u884c\u4efb\u4f55\u64cd\u4f5c\n     * */\n    void insert(T val) {\n        _insert(&amp;root, val);\n    }\n\n    /**\n     * @brief \u68c0\u67e5\u7ed3\u70b9\u662f\u5426\u5728AVL\u6811\u4e2d\n     * @param val \u9700\u8981\u68c0\u67e5\u7684\u503c\n     * */\n    bool exist(T val) {\n        auto ptr = &amp;root;\n        while (*ptr != nullptr) {\n            if (val == (*ptr)-&gt;data) {\n                return true;\n            } else if (val &lt; (*ptr)-&gt;data) {\n                *ptr = (*ptr)-&gt;leftChild;\n            } else {\n                *ptr = (*ptr)-&gt;rightChild;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @brief \u627e\u5230\u503c\u4e3aval\u7684\u7ed3\u70b9\n     * @param val \u76ee\u6807\u503c\n     * @return \u8fd4\u56de\u503c\u4e3a\u6307\u5411\u8be5\u7ed3\u70b9\u7684\u6307\u9488\u7684\u5730\u5740\n     */\n    AVLNode&lt;T&gt; **find(T val) {\n        auto ptr = &amp;root;\n        while ((*ptr) != nullptr) {\n            if (val == (*ptr)-&gt;data) {\n                break;\n            } else if (val &lt; (*ptr)-&gt;data) {\n                *ptr = (*ptr)-&gt;leftChild;\n            } else {\n                *ptr = (*ptr)-&gt;rightChild;\n            }\n        }\n        return ptr;\n    }\n\n    /**\n     * @brief \u5220\u9664\u7ed3\u70b9\n     * @note \u9996\u5148\u627e\u5230\u7ed3\u70b9\uff0c\u7136\u540e\u5c06\u7ed3\u70b9\u65cb\u8f6c\u5230\u53f6\u5b50\u7ed3\u70b9\uff0c\u7136\u540e\u56de\u6eaf\u68c0\u67e5\u6811\u7684\u5e73\u8861\u6027\n     * @param val \u9700\u8981\u5220\u9664\u7684\u7ed3\u70b9\u7684\u503c\n     * @note \u8fd9\u4e2a\u5730\u65b9\u9700\u8981\u9012\u5f52\u5bfb\u627e\u8be5\u503c\u7684\u7ed3\u70b9\uff0c\u56e0\u4e3a\u9700\u8981\u56de\u6eaf\u66f4\u65b0\u5e73\u8861\u6811\n     * */\n    void remove(T val) {\n        _remove(&amp;root, val);\n    }\n\n\nprivate:\n    void _remove(AVLNode&lt;T&gt; **ptr, T val) {\n        if (*ptr == nullptr) {\n            return;\n        }\n        if ((*ptr)-&gt;data == val) {\n            _rotateNodeToLeaf(ptr);\n        } else if ((*ptr)-&gt;data &lt; val) {\n            _remove(&amp;((*ptr)-&gt;rightChild), val);\n        } else {\n            _remove(&amp;((*ptr)-&gt;leftChild), val);\n        }\n        // \u5b8c\u4e86\u4e4b\u540e\u56de\u6eaf\uff0c\u91cd\u65b0\u5e73\u8861\u4e8c\u53c9\u6811\n        _balance(ptr);\n        _updateHeight(*ptr);\n    }\n\n    /**\n     * @brief \u5c06\u4e00\u4e2a\u7ed3\u70b9\u65cb\u8f6c\u5230\u53f6\u5b50\u7ed3\u70b9\n     * @param ptr \u5c06\u8981\u88ab\u65cb\u8f6c\u81f3\u53f6\u5b50\u7684\u7ed3\u70b9\u7684\u6307\u9488\u7684\u5730\u5740\n     * @note \u65cb\u8f6c\u7684\u65f6\u5019\uff0c\u5c06\u5f53\u524d\u7ed3\u70b9\u65cb\u8f6c\u5230\u9ad8\u5ea6\u6bd4\u8f83\u5c0f\u7684\u4e00\u8fb9\u3002\n     */\n    void _rotateNodeToLeaf(AVLNode&lt;T&gt; **ptr) {\n        // \u5f53\u524d\u7ed3\u70b9\u5df2\u7ecf\u662f\u53f6\u5b50\u7ed3\u70b9\u4e86\n        if ((*ptr)-&gt;leftChild == nullptr and (*ptr)-&gt;rightChild == nullptr) {\n            *ptr = nullptr;\n            return;\n        }\n        int leftHeight = (*ptr)-&gt;leftChild != nullptr ? (*ptr)-&gt;leftChild-&gt;height : 0;\n        int rightHeight = (*ptr)-&gt;rightChild != nullptr ? (*ptr)-&gt;rightChild-&gt;height : 0;\n        // \u5de6\u8fb9\u9ad8\u5ea6\u6bd4\u8f83\u5c0f\uff0c\u5de6\u65cb\n        if (leftHeight &lt;= rightHeight) {\n            _leftRotate(ptr);\n            _rotateNodeToLeaf(&amp;((*ptr)-&gt;leftChild));\n        } else {\n            // \u53f3\u65cb\n            _rightRotate(ptr);\n            _rotateNodeToLeaf(&amp;((*ptr)-&gt;rightChild));\n        }\n        _balance(ptr);\n        _updateHeight(*ptr);\n    }\n\n    /**\n     * @brief \u63d2\u5165\u7ed3\u70b9\n     *\n     * */\n    void _insert(AVLNode&lt;T&gt; **ptr, T val) {\n        if (*ptr == nullptr) {\n            *ptr = new AVLNode&lt;T&gt;(val);\n            return;\n        }\n        if (val &lt; (*ptr)-&gt;data) {\n            _insert(&amp;((*ptr)-&gt;leftChild), val);\n        } else if (val &gt; (*ptr)-&gt;data) {\n            _insert(&amp;((*ptr)-&gt;rightChild), val);\n        } else {\n            // \u5982\u679c\u5f53\u524d\u5e73\u8861\u4e8c\u53c9\u6811\u4e2d\u5df2\u7ecf\u5b58\u5728\u8fd9\u4e2a\u7ed3\u70b9\u4e86\uff0c\u4e0d\u505a\u4efb\u4f55\u5904\u7406\n            return;\n        }\n        _balance(ptr);\n        _updateHeight(*ptr);\n    }\n\n    /**\n     * @brief \u5e73\u8861\u7ed3\u70b9\n     *\n     * */\n    void _balance(AVLNode&lt;T&gt; **ptr) {\n        if (*ptr == nullptr) return;\n        int leftHeight = (*ptr)-&gt;leftChild != nullptr ? (*ptr)-&gt;leftChild-&gt;height : 0;\n        int rightHeight = (*ptr)-&gt;rightChild != nullptr ? (*ptr)-&gt;rightChild-&gt;height : 0;\n        if (abs(leftHeight - rightHeight) &lt;= 1) return;\n\n        if (leftHeight &lt; rightHeight) {\n            auto rightElement = (*ptr)-&gt;rightChild;\n            int rightElementLeftHeight = rightElement-&gt;leftChild != nullptr ? rightElement-&gt;leftChild-&gt;height : 0;\n            int rightElementRightHeight = rightElement-&gt;rightChild != nullptr ? rightElement-&gt;rightChild-&gt;height : 0;\n            if (rightElementLeftHeight &lt; rightElementRightHeight) {\n                // RR\n                _leftRotate(ptr);\n            } else {\n                // RL\n                _rightRotate(&amp;((*ptr)-&gt;rightChild));\n                _leftRotate(ptr);\n            }\n        } else {\n            auto leftElement = (*ptr)-&gt;leftChild;\n            int leftElementLeftHeight = leftElement-&gt;leftChild != nullptr ? leftElement-&gt;leftChild-&gt;height : 0;\n            int leftElementRightHeight = leftElement-&gt;rightChild != nullptr ? leftElement-&gt;rightChild-&gt;height : 0;\n            if (leftElementLeftHeight &gt; leftElementRightHeight) {\n                // LL\n                _rightRotate(ptr);\n            } else {\n                // LR\n                _leftRotate(&amp;((*ptr)-&gt;leftChild));\n                _rightRotate(ptr);\n            }\n        }\n    }\n\n    /**\n     * @brief \u53f3\u65cb\n     *\n     * */\n    void _rightRotate(AVLNode&lt;T&gt; **ptr) {\n        auto tmp = (*ptr)-&gt;leftChild;\n        (*ptr)-&gt;leftChild = tmp-&gt;rightChild;\n        tmp-&gt;rightChild = *ptr;\n        _updateHeight(tmp);\n        _updateHeight(*ptr);\n        *ptr = tmp;\n    }\n\n    /**\n     * @brief \u5de6\u65cb\n     * */\n    void _leftRotate(AVLNode&lt;T&gt; **ptr) {\n        auto tmp = (*ptr)-&gt;rightChild;\n        (*ptr)-&gt;rightChild = tmp-&gt;leftChild;\n        tmp-&gt;leftChild = *ptr;\n        _updateHeight(tmp);\n        _updateHeight(*ptr);\n        *ptr = tmp;\n    }\n\n    void _updateHeight(AVLNode&lt;T&gt; *ptr) {\n        if (ptr == nullptr) return;\n        int leftHeight = ptr-&gt;leftChild != nullptr ? ptr-&gt;leftChild-&gt;height : 0;\n        int rightHeight = ptr-&gt;rightChild != nullptr ? ptr-&gt;rightChild-&gt;height : 0;\n        ptr-&gt;height = std::max(leftHeight, rightHeight) + 1;\n    }\n\n    AVLNode&lt;T&gt; *root;\n};\n\nint main() {\n    auto avl = new AVL&lt;int&gt;();\n    int n = 20;\n    std::random_device rd{};\n    std::mt19937 gen{rd()};\n    std::normal_distribution&lt;&gt; d{100, 100};\n    std::uniform_int_distribution&lt;int&gt; u(0, INT_MAX &gt;&gt; 1);\n    std::vector&lt;int&gt; vec;\n    for (int i = 0; i &lt; n; ++i) {\n        vec.push_back((int) std::round(d(gen)));\n        //vec.push_back(i);\n    }\n    for (auto it : vec) {\n        avl-&gt;insert(it);\n    }\n    avl-&gt;remove(15);\n    avl-&gt;remove(32);\n    avl-&gt;remove(31);\n    std::cout &lt;&lt; *avl &lt;&lt; std::endl;\n    delete avl;\n    return 0;\n}\n</code></pre>"},{"location":"game/","title":"\u6e38\u620f","text":""},{"location":"game/#\u5fb7\u5dde\u6251\u514b","title":"\u5fb7\u5dde\u6251\u514b","text":"<p>\u5fb7\u5dde\u6251\u514b \uff08Texas hold'em\uff0c\u6709\u65f6\u4e5f\u7b80\u79f0\u4e3aHold'em\u6216Holdem\uff09\uff0c\u7b80\u79f0\u5fb7\u6251\uff0c\u662f\u4e16\u754c\u4e0a\u6700\u6d41\u884c\u7684\u516c\u724c\u6251\u514b\u884d\u751f\u6e38\u620f\uff0c\u4e5f\u662f\u56fd\u9645\u6251\u514b\u6bd4\u8d5b\u7684\u6b63\u5f0f\u7ade\u8d5b\u9879\u76ee\u4e4b\u4e00\u3002\u4e16\u754c\u6251\u514b\u5927\u8d5b\uff08World Series of Poker, WSOP\uff09\u548c\u4e16\u754c\u6251\u514b\u5de1\u56de\u8d5b\uff08World Poker Tour\uff0cWPT\uff09\u7684\u4e3b\u8d5b\u4e8b\uff08Main Event\uff09\u9879\u76ee\u5373\u662f\u201c\u65e0\u9650\u6ce8\u5fb7\u5dde\u6251\u514b\u201d\u3002\u5fb7\u5dde\u6251\u514b\u662f\u4f4d\u7f6e\u987a\u5e8f\u5f71\u54cd\u6700\u5927\u7684\u6251\u514b\u884d\u751f\u6e38\u620f\u4e4b\u4e00\uff0c\u6bcf\u4e00\u8f6e\u7684\u4e0b\u6ce8\u987a\u5e8f\u7ef4\u6301\u4e0d\u53d8\uff0c\u5b83\u4e5f\u662f\u7f8e\u56fd\u591a\u6570\u8d4c\u573a\u5185\u6700\u53d7\u6b22\u8fce\u7684\u6251\u514b\u724c\u7c7b\u6e38\u620f\uff0c\u5728\u7f8e\u56fd\u4ee5\u5916\u7684\u5730\u533a\u4e5f\u5341\u5206\u6d41\u884c\uff0c\u4e0e\u6865\u724c\u7684\u6d41\u884c\u7a0b\u5ea6\u76f8\u5f53\u3002\u7406\u8bba\u4e0a\u4e00\u684c\u540c\u65f6\u6700\u591a\u53ef\u5bb9\u7eb322\u4f4d\uff08\u82e5\u4e0d\u9500\u724c\u5219\u4e3a23\u4f4d\uff09\u724c\u624b\uff0c\u4f46\u4e00\u822c\u662f\u4e8c\u81f3\u5341\u4eba\u4e00\u684c\u3002</p> <pre><code>namespace holdem {\nenum Suit {\n    HighCard,           // \u9ad8\u724c\n    Pair,               // \u5bf9\u5b50\n    TwoPair,            // \u4e24\u5bf9\n    ThreeOfAKind,       // \u4e09\u6761\n    Straight,           // \u987a\u5b50\n    Flush,              // \u540c\u82b1\n    FullHouse,          // \u846b\u82a6\n    FourOfAKind,        // \u94c1\u652f\n    StraightFlush,      // \u540c\u82b1\u987a\n    RoyalStraightFlush  // \u540c\u82b1\u5927\u987a\n};\n\nenum CardType {\n    Two = 0,\n    Three = 1,\n    Four = 2,\n    Five = 3,\n    Six = 4,\n    Seven = 5,\n    Eight = 6,\n    Nine = 7,\n    Ten = 8,\n    Jack = 9,\n    Queen = 10,\n    King = 11,\n    Ace = 12\n};\n\nenum Color {\n    Heart = 0,    // \u2665\n    Spade = 1,    // \u2660\n    Club = 2,     // \u2663\n    Diamond = 3   // \u2666\n};\n\n// \u4e00\u5f20\u5361\u724c\uff0c\u7528\u7c7b\u578b\u548c\u989c\u8272\u8868\u793a\nusing Card = std::pair&lt;CardType, Color&gt;;\n\nbool operator&lt;(const Card &amp;lhs, const Card &amp;rhs) {\n    return lhs.first &lt; rhs.first;\n}\n\n// \u624b\u724c\u5206\u6570\uff0c\u7528\u724c\u578b\u548c\u5206\u6570\u5224\u65ad\uff0c\u5206\u6570\u53ea\u5bf9\u76f8\u540c\u724c\u578b\u6709\u6548\nusing Score = std::pair&lt;Suit, int&gt;;\n\nbool operator&lt;(const Score &amp;lhs, const Score &amp;rhs) {\n    return lhs.first &lt; rhs.first or (lhs.first == rhs.first and lhs.second &lt; rhs.second);\n}\n\n// \u624b\u724c\nstruct Hand {\n    // \u989c\u8272\uff0c\u7528\u4f4d\u8868\u793a\u6bcf\u5f20\u624b\u724c\u662f\u5426\u5b58\u5728\n    std::array&lt;short, 4&gt; color{};\n    // \u6570\u76ee\uff0c\u5b58\u653e\u6bcf\u79cd\u5361\u724c\u7684\u6570\u76ee\n    std::array&lt;short, 13&gt; type{};\n    void clear(){\n        std::fill(color.begin(), color.end(), 0);\n        std::fill(type.begin(), type.end(), 0);\n    }\n    void addCard(const Card&amp; c){\n        color[c.second] += (1 &lt;&lt; c.first);\n        type[c.first]++;\n    }\n    void removeCard(const Card&amp; c){\n        color[c.second] -= (1 &lt;&lt; c.first);\n        type[c.first]--;\n    }\n};\n\nScore getType(const Hand &amp;hand) {\n\n    auto&amp; colors = hand.color;\n    auto&amp; types = hand.type;\n    // is RoyalStraightFlush\n    for (short i = 0; i &lt; 4; ++i) {\n        if ((colors[i] &amp; 0b111110000000000) == 0b111110000000000) {\n            return {RoyalStraightFlush, 0};\n        }\n    }\n    // is StraightFlush\n    {\n        int tv = 0b111110000000000;\n        for (short i = Ace; i &gt;= Five; --i) {\n            for(int j = 0; j &lt; 4; ++j){\n                if((colors[j] &amp; tv) == tv){\n                    return {StraightFlush, i};\n                }\n            }\n            tv &gt;&gt;= 1;\n            if(__builtin_popcount(tv) &lt; 5) tv |= (1 &lt;&lt; 12);\n        }\n    }\n    // is FourOfAKind\n    {\n        for (short i = Ace; i &gt;= Two; --i) {\n            if (types[i] &gt;= 4) {\n                for (short j = Ace; j &gt;= Two; --j) {\n                    if (j == i) continue;\n                    if (types[j] &gt; 0) {\n                        return {FourOfAKind, i * 13 + j};\n                    }\n                }\n            }\n        }\n    }\n    // is FullHouse\n    {\n        for (short i = Ace; i &gt;= Two; --i) {\n            if (types[i] &gt;= 3) {\n                for (short j = Ace; j &gt;= Two; --j) {\n                    if (j == i) continue;\n                    if (types[j] &gt;= 2) {\n                        return {FullHouse, i * 13 + j};\n                    }\n                }\n            }\n        }\n    }\n    // is Flush\n    {\n        int score = 0;\n        for (short c = 0; c &lt; 4; ++c) {\n            if (__builtin_popcount(colors[c]) &gt;= 5) {\n                int tScore = 0;\n                for (int j = Ace; j &gt;= Two and __builtin_popcount(tScore) &lt; 5; --j) {\n                    tScore |= (colors[c] &amp; (1 &lt;&lt; j));\n                }\n                score = std::max(score, tScore);\n            }\n        }\n        if (score) return {Flush, score};\n    }\n    // is Straight\n    {\n        for (int i = Ace; i &gt;= Five; --i) {\n            bool ok = true;\n            for (int j = 0; j &lt; 5 and ok; ++j) {\n                int p = (i + 13 - j) % 13;\n                if (types[p] == 0) {\n                    ok = false;\n                }\n            }\n            if (ok) {\n                return {Straight, i};\n            }\n        }\n    }\n    // is ThreeOfAKind\n    {\n        for (int i = Ace; i &gt;= Two; --i) {\n            if (types[i] &gt;= 3) {\n                std::vector&lt;int&gt; others;\n                for (int j = Ace; j &gt;= Two and others.size() &lt; 2; --j) {\n                    if (types[j] &gt; 0) {\n                        others.push_back(j);\n                    }\n                }\n                return {ThreeOfAKind, i * 169 + others[0] * 13 + others[1]};\n            }\n        }\n    }\n    // is TwoPair\n    {\n        std::vector&lt;int&gt; pairs;\n        for (int i = Ace; i &gt;= Two and pairs.size() &lt; 2; --i) {\n            if (types[i] &gt;= 2) {\n                pairs.push_back(i);\n            }\n        }\n        if (pairs.size() &gt;= 2) {\n            for (int i = Ace; i &gt;= Two; --i) {\n                if (types[i] &gt; 0) {\n                    return {TwoPair, pairs[0] * 169 + pairs[1] * 13 + i};\n                }\n            }\n        }\n    }\n    // is Pair\n    {\n        for (int i = Ace; i &gt;= Two; --i) {\n            if (types[i] &gt;= 2) {\n                int score = i;\n                for (int j = Ace, cnt = 0; j &gt;= Two and cnt &lt; 3; --j) {\n                    if (j == i) continue;\n                    if (types[j] &gt; 0) {\n                        ++cnt;\n                        score = score * 13 + j;\n                    }\n                }\n                return {Pair, score};\n            }\n        }\n    }\n    // HighCard\n    int highScore = 0;\n    for (int i = Ace, cnt = 0; i &gt;= Two and cnt &lt; 5; --i) {\n        if (types[i]) {\n            highScore = highScore * 13 + i;\n            ++cnt;\n        }\n    }\n    return {HighCard, highScore};\n}\n\nchar cardType2char(CardType ct) {\n    return \"23456789TJQKA\"[ct];\n}\n\nCardType char2cardType(char c) {\n    switch (c) {\n        case '2':\n            return Two;\n        case '3':\n            return Three;\n        case '4':\n            return Four;\n        case '5':\n            return Five;\n        case '6':\n            return Six;\n        case '7':\n            return Seven;\n        case '8':\n            return Eight;\n        case '9':\n            return Nine;\n        case 'T':\n            return Ten;\n        case 'J':\n            return Jack;\n        case 'Q':\n            return Queen;\n        case 'K':\n            return King;\n        default:\n            return Ace;\n    }\n}\n}\n\n</code></pre>"},{"location":"geometry/","title":"\u8ba1\u7b97\u51e0\u4f55","text":""},{"location":"geometry/#\u8ba1\u7b97\u51e0\u4f55","title":"\u8ba1\u7b97\u51e0\u4f55","text":""},{"location":"geometry/#\u6781\u89d2\u6392\u5e8f","title":"\u6781\u89d2\u6392\u5e8f","text":"<pre><code>\nstruct Point{\n    ll x, y;\n    Point() = default;\n    Point(int argx, int argy): x(argx), y(argy){}\n    bool up() const{\n        return y &gt; 0 or (y == 0 and x &gt;= 0);\n    }\n};\nll det(const Point&amp; a, const Point&amp; b) {\n    return a.x * b.y - b.x * a.y;\n}\n\nll dot(const Point&amp; a, const Point&amp; b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nbool cmp(const Point&amp; a, const Point&amp; b) {\n    if (a.up() ^ b.up()) return a.up() &gt; b.up();\n    return det(a, b) &gt; 0;\n}\n\nbool same(const Point&amp; a, const Point&amp; b) {\n    ll d = det (a, b);\n    if (d &gt; 0) return true;\n    if (d &lt; 0) return false;\n    return dot (a, b) &gt; 0;\n}\n\n</code></pre>"},{"location":"geometry/#\u51f8\u5305","title":"\u51f8\u5305","text":"<pre><code>// \u57fa\u672c\u6570\u636e\u7c7b\u578b\uff0c\u9762\u79ef\u548c\u8fb9\u957f\u7684\u6570\u636e\ntemplate&lt;typename T, typename AFT&gt;\nclass Andrew{\n    typedef pair&lt;T, T&gt; PTT;\n    PTT reduce(PTT a, PTT b){\n        return PTT{a.first - b.first, a.second - b.second};\n    }\n    T cross(PTT a, PTT b){\n        return a.first * b.second - a.second * b.first;\n    }\n    T area(PTT a, PTT b, PTT c){\n        return cross(reduce(b , a), reduce(c , a));\n    }\n    AFT dist(PTT a, PTT b){\n        AFT dx = a.first - b.first;\n        AFT dy = a.second - b.second;\n        return sqrt(dx * dx + dy * dy);\n    }\npublic:\n    Andrew()= default;\n    Andrew(const vector&lt;PTT&gt;&amp; argv): vec(argv){}\n    void addPoint(PTT p){\n        vec.push_back(p);\n    }\n    // \u8fb9\u957f\uff0c \u9762\u79ef\uff0c \u6309\u8282\u70b9\u987a\u5e8f\u7684\u8fb9\u7f18\u8282\u70b9\u5e8f\u5217\uff08\u7b2c\u4e00\u4e2a\u70b9\u548c\u6700\u540e\u4e00\u4e2a\u70b9\u662f\u4e00\u6837\u7684\uff09\n    // \u6ce8\u610f\uff1a\u5982\u679c\u8003\u8651\u51f8\u5305\u4e0a\u70b9\u7684\u6570\u76ee\u6700\u5c11\uff0c\u9700\u8981\u5c06while\u5faa\u73af\u5141\u8bb8\u9762\u79ef\u7b49\u4e8e0\n    tuple&lt;T, T, vector&lt;PTT&gt;&gt; run(){\n        sort(vec.begin(), vec.end());\n        vector&lt;int&gt; st;\n        // vis\u662f\u7528\u6765\u8bb0\u5f55\u7b2c\u4e00\u904d\u8bbf\u95ee\u7684\u8282\u70b9\uff0c\u800c\u4e0d\u662f\u6700\u7ec8\u5728\u51f8\u5305\u4e0a\u9762\u7684\u70b9\n        vector&lt;bool&gt; vis(vec.size(), false);\n        for(int i = 0; i &lt; vec.size(); ++i){\n            while(st.size() &gt;= 2 and area(vec[*next(st.rbegin(), 1)], vec[*st.rbegin()], vec[i]) &lt; 0){\n                if(area(vec[*next(st.rbegin(), 1)], vec[*st.rbegin()], vec[i]) &lt; 0){\n                    vis[st.back()] = false;\n                }\n                st.pop_back();\n            }\n            st.push_back(i);\n            vis[st.back()] = true;\n        }\n        vis[0] = false;\n        for(int i = (int)vec.size() - 1; i &gt;= 0; --i){\n            if(vis[i]) continue;\n            while(st.size() &gt;= 2 and area(vec[*next(st.rbegin(), 1)], vec[*st.rbegin()], vec[i]) &lt; 0){\n                st.pop_back();\n            }\n            st.push_back(i);\n        }\n        AFT dis = 0;\n        AFT ars = 0;\n        vector&lt;PTT&gt; res;\n        for(auto&amp; it: st) res.push_back(vec[it]);\n        for(int i = 1; i &lt; st.size(); ++i){\n            dis += dist(vec[st[i - 1]], vec[st[i]]);\n            ars += area(vec[0], vec[st[i - 1]], vec[st[i]]);\n        }\n        return {dis, ars, res};\n    }\nprivate:\n    vector&lt;PTT&gt; vec;\n};\n\n</code></pre>"},{"location":"geometry/#\u65b9\u9635\u7684\u4e09\u7ef4\u64cd\u4f5c\u6a21\u677f","title":"\u65b9\u9635\u7684\u4e09\u7ef4\u64cd\u4f5c\u6a21\u677f","text":"<p>\u7ffb\u8f6c\uff0c\u65cb\u8f6c\u548c\u8f6c\u7f6e</p> <pre><code>class Rectangle{\npublic:\n    typedef pair&lt;int, int&gt; Point;\n    Rectangle(int sx, int sy) : dx({1, 0}), dy({0, 1}), vec({Point{0, 0}, Point{0, sy - 1}, Point{sx - 1, 0}, Point{sx - 1, sy - 1}}){}\n    void mirror(int dr = 1){\n        if(dr == 1){\n            // \u6cbf\u7740x\u8f74\u7ffb\u8f6c\n            swap(vec[0], vec[1]);\n            swap(vec[2], vec[3]);\n        }else{\n            // \u6cbf\u7740y\u8f74\u7ffb\u8f6c\n            swap(vec[0], vec[2]);\n            swap(vec[1], vec[3]);\n        }\n        update();\n    }\n    void transpose(int dr = 1){\n        if(dr == 1){\n            // \u6cbf\u7740y = x \u7ffb\u8f6c\n            swap(vec[1], vec[2]);\n        }else{\n            // \u6cbf\u7740x + y = n \u7ffb\u8f6c\n            swap(vec[0], vec[3]);\n        }\n        update();\n    }\n    void rotate(int dr = 1){\n        transpose();\n        if(dr == 1){\n            // \u987a\u65f6\u9488\n            mirror(1);\n        }else{\n            // \u9006\u65f6\u9488\n            mirror(0);\n        }\n        update();\n    }\n    Point mapping(Point p){\n        return {vec[0].first + dx.first * p.first + dy.first * p.second, vec[0].second + dx.second * p.first + dy.second * p.second};\n    }\n    Point dx, dy;\n    array&lt;Point, 4&gt; vec;\nprivate:\n    void update(){\n        int xlim = abs(vec[2].first - vec[0].first) + abs(vec[2].second - vec[0].second);\n        int ylim = abs(vec[1].first - vec[0].first) + abs(vec[1].second - vec[0].second);\n        assert(xlim &gt; 0 and ylim &gt; 0);\n        dx = Point{(vec[2].first - vec[0].first) / xlim, (vec[2].second - vec[0].second) / xlim};\n        dy = Point{(vec[1].first - vec[0].first) / ylim, (vec[1].second - vec[0].second) / ylim};\n    }\n};\n</code></pre>"},{"location":"graph/","title":"\u56fe\u8bba","text":""},{"location":"graph/#\u56fe\u8bba","title":"\u56fe\u8bba","text":""},{"location":"graph/#\u5e76\u67e5\u96c6dsu","title":"\u5e76\u67e5\u96c6\uff08DSU\uff09","text":"<p>\u80fdCopy\u7684\u65f6\u5019\uff0c\u5c31\u4e0d\u7528\u624b\u6413\u4e86</p> <pre><code>class DSU{\npublic:\n    explicit DSU(int size_): sz(size_), fa(size_, 0), cnt(size_, 1) {\n        iota(fa.begin(), fa.end(), 0);\n    }\n    int tf(int x){\n        return x == fa[x] ? x : fa[x] = tf(fa[x]);\n    }\n    bool mg(int x, int y){\n        int tx = tf(x), ty = tf(y);\n        if(tx != ty){\n            if(cnt[tx] &gt;= cnt[ty]){ // \u542f\u53d1\u5f0f\u5408\u5e76\n                fa[ty] = tx;\n                cnt[tx] += cnt[ty];\n            }else{\n                fa[tx] = ty;\n                cnt[ty] += cnt[tx];\n            }\n            return true;\n        }\n        return false;\n    }\n    pair&lt;int, int&gt; operator [] (const int idx) {\n        return {tf(idx), cnt[tf(idx)]};\n    }\n    int size(){\n        return sz;\n    }\nprivate:\n    int sz;\n    vector&lt;int&gt; fa, cnt;\n};\n\n</code></pre>"},{"location":"graph/#\u7f51\u7edc\u6d41","title":"\u7f51\u7edc\u6d41","text":""},{"location":"graph/#\u6700\u5927\u6d41dinic","title":"\u6700\u5927\u6d41(Dinic)","text":"<pre><code>template&lt;typename cap_t&gt;\nclass Dinic{\npublic:\n    explicit Dinic(int n): node_cnt(n), g(n){}\n    int add_edge(int from, int to, cap_t cap){\n        int m = int(pos.size());\n        pos.emplace_back(from, int(g[from].size()));\n        int from_id = int(g[from].size());\n        int to_id = int(g[to].size());\n        if(from == to) to_id++;\n        g[from].push_back(PrivateEdge{to, to_id, cap});\n        g[to].push_back(PrivateEdge{from, from_id, 0});\n        return m;\n    }\n    struct Edge{\n        int from, to;\n        cap_t cap, flow;\n    };\n    Edge getEdge(int idx){\n        auto _e = g[pos[idx].first][pos[idx].second];\n        auto _re = g[_e.to][_e.rev];\n        return Edge{pos[idx].first, _e.to, _e.cap + _re.cap, _re.cap};\n    }\n    std::vector&lt;Edge&gt; getEdges(){\n        std::vector&lt;Edge&gt; result;\n        for(int i = 0; i &lt; pos.size(); ++i){\n            result.push_back(getEdge(i));\n        }\n        return result;\n    }\n    cap_t flow(int st, int ed){\n        return flow(st, ed, std::numeric_limits&lt;cap_t&gt;::max());\n    }\n    cap_t flow(int st, int ed, cap_t flow_limit){\n        std::vector&lt;int&gt; level(node_cnt);\n        std::queue&lt;int&gt; que;\n        auto&amp;&amp; bfs = [&amp;](){\n            std::fill(level.begin(), level.end(), -1);\n            level[st] = 0;\n            while(!que.empty()){\n                que.pop();\n            }\n            que.push(st);\n            while(!que.empty()){\n                int v = que.front();\n                que.pop();\n                for(PrivateEdge&amp; e: g[v]){\n                    if(e.cap == 0 or level[e.to] &gt;= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    if(e.to == ed) continue;\n                    que.push(e.to);\n                }\n            }\n        };\n        auto&amp;&amp; dfs = [&amp;](auto&amp;&amp; self, int v, cap_t up){\n            if(v == st) return up;\n            cap_t res = 0;\n            int level_v = level[v];\n            for(int idx = 0; idx &lt; int(g[v].size()); ++idx){\n                PrivateEdge&amp; edge = g[v][idx];\n                if(level_v &lt;= level[edge.to] or g[edge.to][edge.rev].cap == 0) continue;\n                cap_t delta = self(self, edge.to, std::min(up - res, g[edge.to][edge.rev].cap));\n                if(delta &lt;= 0) continue;\n                g[v][idx].cap += delta;\n                g[edge.to][edge.rev].cap -= delta;\n                res += delta;\n                if(res == up) return res;\n            }\n            level[v] = node_cnt;\n            return res;\n        };\n        cap_t ans = 0;\n        while (ans &lt; flow_limit){\n            bfs();\n            if(level[ed] == -1) break;\n            cap_t delta = dfs(dfs, ed, flow_limit - ans);\n            if(!delta) break;\n            ans += delta;\n        }\n        return ans;\n    }\nprivate:\n    struct PrivateEdge{\n        int to, rev;\n        cap_t cap;\n    };\n    int node_cnt;\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; pos;\n    std::vector&lt;std::vector&lt;PrivateEdge&gt;&gt; g;\n};\n</code></pre>"},{"location":"graph/#\u6700\u5c0f\u8d39\u7528\u6d41dinic","title":"\u6700\u5c0f\u8d39\u7528\u6d41(Dinic)","text":"<p>Atcoder</p> <pre><code>template &lt;class Cap, class Cost&gt; struct mcf_graph {\npublic:\n    mcf_graph() {}\n    explicit mcf_graph(int n) : _n(n) {}\n\n    int add_edge(int from, int to, Cap cap, Cost cost) {\n        assert(0 &lt;= from &amp;&amp; from &lt; _n);\n        assert(0 &lt;= to &amp;&amp; to &lt; _n);\n        assert(0 &lt;= cap);\n        assert(0 &lt;= cost);\n        int m = int(_edges.size());\n        _edges.push_back({from, to, cap, 0, cost});\n        return m;\n    }\n\n    struct edge {\n        int from, to;\n        Cap cap, flow;\n        Cost cost;\n    };\n\n    template &lt;class E&gt; struct csr {\n        std::vector&lt;int&gt; start;\n        std::vector&lt;E&gt; elist;\n        explicit csr(int n, const std::vector&lt;std::pair&lt;int, E&gt;&gt;&amp; edges)\n            : start(n + 1), elist(edges.size()) {\n            for (auto e : edges) {\n                start[e.first + 1]++;\n            }\n            for (int i = 1; i &lt;= n; i++) {\n                start[i] += start[i - 1];\n            }\n            auto counter = start;\n            for (auto e : edges) {\n                elist[counter[e.first]++] = e.second;\n            }\n        }\n    };\n\n    edge get_edge(int i) {\n        int m = int(_edges.size());\n        assert(0 &lt;= i &amp;&amp; i &lt; m);\n        return _edges[i];\n    }\n    std::vector&lt;edge&gt; edges() { return _edges; }\n\n    std::pair&lt;Cap, Cost&gt; flow(int s, int t) {\n        return flow(s, t, std::numeric_limits&lt;Cap&gt;::max());\n    }\n    std::pair&lt;Cap, Cost&gt; flow(int s, int t, Cap flow_limit) {\n        return slope(s, t, flow_limit).back();\n    }\n    std::vector&lt;std::pair&lt;Cap, Cost&gt;&gt; slope(int s, int t) {\n        return slope(s, t, std::numeric_limits&lt;Cap&gt;::max());\n    }\n    std::vector&lt;std::pair&lt;Cap, Cost&gt;&gt; slope(int s, int t, Cap flow_limit) {\n        assert(0 &lt;= s &amp;&amp; s &lt; _n);\n        assert(0 &lt;= t &amp;&amp; t &lt; _n);\n        assert(s != t);\n\n        int m = int(_edges.size());\n        std::vector&lt;int&gt; edge_idx(m);\n\n        auto g = [&amp;]() {\n            std::vector&lt;int&gt; degree(_n), redge_idx(m);\n            std::vector&lt;std::pair&lt;int, _edge&gt;&gt; elist;\n            elist.reserve(2 * m);\n            for (int i = 0; i &lt; m; i++) {\n                auto e = _edges[i];\n                edge_idx[i] = degree[e.from]++;\n                redge_idx[i] = degree[e.to]++;\n                elist.push_back({e.from, {e.to, -1, e.cap - e.flow, e.cost}});\n                elist.push_back({e.to, {e.from, -1, e.flow, -e.cost}});\n            }\n            auto _g = csr&lt;_edge&gt;(_n, elist);\n            for (int i = 0; i &lt; m; i++) {\n                auto e = _edges[i];\n                edge_idx[i] += _g.start[e.from];\n                redge_idx[i] += _g.start[e.to];\n                _g.elist[edge_idx[i]].rev = redge_idx[i];\n                _g.elist[redge_idx[i]].rev = edge_idx[i];\n            }\n            return _g;\n        }();\n\n        auto result = slope(g, s, t, flow_limit);\n\n        for (int i = 0; i &lt; m; i++) {\n            auto e = g.elist[edge_idx[i]];\n            _edges[i].flow = _edges[i].cap - e.cap;\n        }\n\n        return result;\n    }\n\nprivate:\n    int _n;\n    std::vector&lt;edge&gt; _edges;\n\n    // inside edge\n    struct _edge {\n        int to, rev;\n        Cap cap;\n        Cost cost;\n    };\n\n    std::vector&lt;std::pair&lt;Cap, Cost&gt;&gt; slope(csr&lt;_edge&gt;&amp; g,\n        int s,\n        int t,\n        Cap flow_limit) {\n        // variants (C = maxcost):\n        // -(n-1)C &lt;= dual[s] &lt;= dual[i] &lt;= dual[t] = 0\n        // reduced cost (= e.cost + dual[e.from] - dual[e.to]) &gt;= 0 for all edge\n\n        // dual_dist[i] = (dual[i], dist[i])\n        std::vector&lt;std::pair&lt;Cost, Cost&gt;&gt; dual_dist(_n);\n        std::vector&lt;int&gt; prev_e(_n);\n        std::vector&lt;bool&gt; vis(_n);\n        struct Q {\n            Cost key;\n            int to;\n            bool operator&lt;(Q r) const { return key &gt; r.key; }\n        };\n        std::vector&lt;int&gt; que_min;\n        std::vector&lt;Q&gt; que;\n        auto dual_ref = [&amp;]() {\n            for (int i = 0; i &lt; _n; i++) {\n                dual_dist[i].second = std::numeric_limits&lt;Cost&gt;::max();\n            }\n            std::fill(vis.begin(), vis.end(), false);\n            que_min.clear();\n            que.clear();\n\n            // que[0..heap_r) was heapified\n            size_t heap_r = 0;\n\n            dual_dist[s].second = 0;\n            que_min.push_back(s);\n            while (!que_min.empty() || !que.empty()) {\n                int v;\n                if (!que_min.empty()) {\n                    v = que_min.back();\n                    que_min.pop_back();\n                } else {\n                    while (heap_r &lt; que.size()) {\n                        heap_r++;\n                        std::push_heap(que.begin(), que.begin() + heap_r);\n                    }\n                    v = que.front().to;\n                    std::pop_heap(que.begin(), que.end());\n                    que.pop_back();\n                    heap_r--;\n                }\n                if (vis[v]) continue;\n                vis[v] = true;\n                if (v == t) break;\n                // dist[v] = shortest(s, v) + dual[s] - dual[v]\n                // dist[v] &gt;= 0 (all reduced cost are positive)\n                // dist[v] &lt;= (n-1)C\n                Cost dual_v = dual_dist[v].first, dist_v = dual_dist[v].second;\n                for (int i = g.start[v]; i &lt; g.start[v + 1]; i++) {\n                    auto e = g.elist[i];\n                    if (!e.cap) continue;\n                    // |-dual[e.to] + dual[v]| &lt;= (n-1)C\n                    // cost &lt;= C - -(n-1)C + 0 = nC\n                    Cost cost = e.cost - dual_dist[e.to].first + dual_v;\n                    if (dual_dist[e.to].second - dist_v &gt; cost) {\n                        Cost dist_to = dist_v + cost;\n                        dual_dist[e.to].second = dist_to;\n                        prev_e[e.to] = e.rev;\n                        if (dist_to == dist_v) {\n                            que_min.push_back(e.to);\n                        } else {\n                            que.push_back(Q{dist_to, e.to});\n                        }\n                    }\n                }\n            }\n            if (!vis[t]) {\n                return false;\n            }\n\n            for (int v = 0; v &lt; _n; v++) {\n                if (!vis[v]) continue;\n                // dual[v] = dual[v] - dist[t] + dist[v]\n                //         = dual[v] - (shortest(s, t) + dual[s] - dual[t]) +\n                //         (shortest(s, v) + dual[s] - dual[v]) = - shortest(s,\n                //         t) + dual[t] + shortest(s, v) = shortest(s, v) -\n                //         shortest(s, t) &gt;= 0 - (n-1)C\n                dual_dist[v].first -= dual_dist[t].second - dual_dist[v].second;\n            }\n            return true;\n        };\n        Cap flow = 0;\n        Cost cost = 0, prev_cost_per_flow = -1;\n        std::vector&lt;std::pair&lt;Cap, Cost&gt;&gt; result = {{Cap(0), Cost(0)}};\n        while (flow &lt; flow_limit) {\n            if (!dual_ref()) break;\n            Cap c = flow_limit - flow;\n            for (int v = t; v != s; v = g.elist[prev_e[v]].to) {\n                c = std::min(c, g.elist[g.elist[prev_e[v]].rev].cap);\n            }\n            for (int v = t; v != s; v = g.elist[prev_e[v]].to) {\n                auto&amp; e = g.elist[prev_e[v]];\n                e.cap += c;\n                g.elist[e.rev].cap -= c;\n            }\n            Cost d = -dual_dist[s].first;\n            flow += c;\n            cost += c * d;\n            if (prev_cost_per_flow == d) {\n                result.pop_back();\n            }\n            result.push_back({flow, cost});\n            prev_cost_per_flow = d;\n        }\n        return result;\n    }\n};\n</code></pre>"},{"location":"graph/#tarjan","title":"Tarjan","text":"<p>\u89e3\u51b3\u5173\u952e\u8fb9\u548c\u5173\u952e\u70b9\u5f88\u597d\u7528</p> <pre><code>const int maxn = 100100;\nint dfn[maxn], low[maxn];\nint tim;\nint vis[maxn];\nint sd[maxn];\nstd::stack&lt;int&gt; st;\nvector&lt;vector&lt;int&gt;&gt; g;\nvoid tarjan(int cur){\n    dfn[cur] = low[cur] = ++tim; \n    vis[cur] = 1;\n    st.push(cur);\n    for(auto&amp; nex: g[cur]){\n        if(!dfn[nex]){\n            tarjan(nex);\n            low[cur] = min(low[cur], low[nex]);\n        }else if(vis[nex]){\n            low[cur] = min(low[cur], dfn[nex]);\n        }\n    }\n    if(dfn[cur] == low[cur]){\n        while(!st.empty()){\n            auto pos = st.top();\n            st.pop();\n            vis[pos] = 0;\n            sd[pos] = cur;\n            if(pos == cur) break;\n        }\n    }\n}\n\n</code></pre>"},{"location":"math/","title":"\u9996\u9875","text":""},{"location":"math/#\u6a21\u6570int","title":"\u6a21\u6570(int)","text":"<pre><code>template&lt;int P&gt;\nclass MI{\npublic:\n    static int selfPow(int base, int p){\n        int ret = 1;\n        while(p){\n            if(p &amp; 1) ret = (ret * 1ll * base) % P;\n            p &gt;&gt;= 1;\n            base = (base * 1ll * base) % P;\n        }\n        return ret;\n    }\n    MI(): _val(0) {}\n    MI(int tv): _val(tv) {}\n    MI operator + (const MI&amp; arg) const { return MI((_val * 1ll + arg._val) % P); }\n    MI operator - (const MI&amp; arg) const { return MI((_val * 1ll + P - arg._val) % P); }\n    MI operator * (const MI&amp; arg) const { return MI((_val * 1ll * arg._val) % P); }\n    MI operator / (const MI&amp; arg) const { return MI((_val * 1ll * selfPow(arg._val, P - 2)) % P); }\n    MI operator + (const int argv) const { return MI((_val * 1ll + argv) % P); }\n    MI operator - (const int argv) const { return MI((_val * 1ll + P - argv) % P); }\n    MI operator * (const int argv) const { return MI((_val * 1ll * argv) % P); }\n    MI operator / (const int argv) const { return MI((_val * 1ll * selfPow(argv, P - 2)) % P); }\n    MI&amp; operator += (const MI&amp; arg){\n        this-&gt;_val = (this-&gt;_val * 1ll + arg._val) % P;\n        return *this;\n    }\n    MI&amp; operator -= (const MI&amp; arg){\n        this-&gt;_val = (this-&gt;_val * 1ll + P - arg._val) % P;\n        return *this;\n    }\n    MI&amp; operator *= (const MI&amp; arg){\n        this-&gt;_val = (this-&gt;_val * 1ll * arg._val) % P;\n        return *this;\n    }\n    MI&amp; operator /= (const MI&amp; arg){\n        this-&gt;_val = (this-&gt;_val * 1ll * selfPow(arg._val, P - 2)) % P;\n        return *this;\n    }\n    MI&amp; operator += (const int argv){\n        this-&gt;_val = (this-&gt;_val * 1ll + argv) % P;\n        return *this;\n    }\n    MI&amp; operator -= (const int argv){\n        this-&gt;_val = (this-&gt;_val * 1ll + P - argv) % P;\n        return *this;\n    }\n    MI&amp; operator *= (const int argv){\n        this-&gt;_val = (this-&gt;_val * 1ll * argv) % P;\n        return *this;\n    }\n    MI&amp; operator /= (const int argv){\n        this-&gt;_val = (this-&gt;_val * 1ll * selfPow(argv, P - 2)) % P;\n        return *this;\n    }\n    MI&amp; operator %= (const int argv){\n        this-&gt;_val %= argv;\n    }\n    MI&amp; operator = (const MI&amp; arg){\n        this-&gt;_val = arg._val % P;\n        return *this;\n    }\n    MI&amp; operator = (const int argv){\n        this-&gt;_val = argv % P;\n        return *this;\n    }\n    bool operator != (const int argv) const {\n        return _val != argv;\n    }\n    bool operator == (const int argv) const{\n        return _val == argv;\n    }\n\n    friend MI operator + (const int argv, const MI&amp; arg){\n        return MI((arg._val * 1ll + argv) % P);\n    }\n    friend MI operator - (const int argv, const MI&amp; arg){\n        return MI((argv * 1ll + P - arg._val) % P);\n    }\n    friend MI operator * (const int argv, const MI&amp; arg){\n        return MI((arg._val * 1ll * argv) % P);\n    }\n    friend MI operator / (const int argv, const MI&amp; arg){\n        return MI((argv * 1ll * MI::selfPow(arg._val, P - 2)) % P);\n    }\n\n    friend std::istream&amp; operator &gt;&gt; (std::istream&amp; its, MI&amp; arg){\n        its &gt;&gt; arg._val;\n        return its;\n    }\n    friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; ots, const MI&amp; arg){\n        ots &lt;&lt; arg._val;\n        return ots;\n    }\n    friend int abs(const MI&amp; arg){\n        return abs(arg._val);\n    }\nprivate:\n    int _val;\n};\n</code></pre>"},{"location":"math/#\u7d20\u6570\u7b5b","title":"\u7d20\u6570\u7b5b","text":""},{"location":"math/#\u5355\u4e2a\u6b63\u6574\u6570\u5224\u65ad\u662f\u4e0d\u662f\u8d28\u6570","title":"\u5355\u4e2a\u6b63\u6574\u6570\u5224\u65ad\u662f\u4e0d\u662f\u8d28\u6570","text":"<pre><code>bool isPrime(int x){\n    if(x &lt;= 1) return false;\n    int cur = 2;\n    while(cur * cur &lt;= x){\n        if(x % cur != 0){\n            return false;\n        }\n        ++cur;\n    }\n    return true;\n}\n</code></pre>"},{"location":"math/#\u57c3\u62c9\u6258\u65af\u7279\u5c3c\u7b5b\u6cd5","title":"\u57c3\u62c9\u6258\u65af\u7279\u5c3c\u7b5b\u6cd5","text":"<pre><code>template&lt;int N&gt;\nvector&lt;int&gt; SieveOfEratosthenes() {\n    vector&lt;int&gt; prime;\n    bitset&lt;N + 1&gt; notPrime;\n    notPrime[0] = notPrime[1] = 1;\n    for (int i = 2; i &lt;= N; ++i) {\n        if (!notPrime[i]) {\n            prime.push_back(i);\n            if ((long long) i * i &lt;= N) {\n                for (int j = i * i; j &lt;= N; j += i) {\n                    notPrime[j] = 1;\n                }\n            }\n        }\n    }\n    return prime;\n}\n\n</code></pre>"},{"location":"math/#\u7ebf\u6027\u7b5b\u6b27\u5f0f\u7b5b","title":"\u7ebf\u6027\u7b5b\uff08\u6b27\u5f0f\u7b5b\uff09","text":"<pre><code>template&lt;int N&gt;\nvector&lt;int&gt; SieveOfEuler() {\n    vector&lt;int&gt; prime;\n    bitset&lt;N + 1&gt; notPrime;\n    for (int i = 2; i &lt;= N; ++i) {\n        if (!notPrime[i]) {\n            prime.push_back(i);\n        }\n        for (auto it : prime) {\n            if ((long long) it * i &lt;= N) {\n                notPrime[it * i] = 1;\n                if (i % it == 0) {\n                    break;\n                }\n            }else{\n                break;\n            }\n        }\n    }\n    return prime;\n}\n</code></pre>"},{"location":"math/#\u5947\u6570\u7b5b","title":"\u5947\u6570\u7b5b","text":"<pre><code>template&lt;int N&gt;\nvector&lt;int&gt; OddFilter() {\n    if (N &lt; 2) return {};\n    vector&lt;int&gt; prime{2};\n    bitset&lt;N + 1&gt; notPrime;\n    notPrime[0] = notPrime[1] = 1;\n    for (int i = 3; i * i &lt;= N; i += 2) {\n        if (!notPrime[i]) {\n            for (int j = i; j * i &lt;= N; j += 2) {\n                notPrime[j * i] = 1;\n            }\n        }\n    }\n    for (int i = 3; i &lt;= N; i += 2) {\n        if (!notPrime[i]) {\n            prime.push_back(i);\n        }\n    }\n    return prime;\n}\n</code></pre>"},{"location":"math/#\u7c7b\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","title":"\u7c7b\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","text":"\\[ \\begin{matrix}     f(N, a, b, c) = \\sum_{i = 0}^N \\lfloor \\frac{a \\times i + b}{c} \\rfloor \\\\       g(N, a, b, c) = \\sum_{i = 0}^N \\lfloor \\frac{a \\times i + b}{c} \\rfloor ^2 \\\\     h(N, a, b, c) = \\sum_{i = 0}^N i \\times \\lfloor \\frac{a \\times i + b}{c} \\rfloor \\end{matrix} \\] <pre><code>##include &lt;iostream&gt;\n##include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int MOD = 998244353;\nint qPow(int b, int p){\n    int ret = 1;\n    while(p){\n        if(p &amp; 1) ret = 1ll * ret * b % MOD;\n        b = 1ll * b * b % MOD;\n        p &gt;&gt;= 1;\n    }\n    return ret;\n}\nconst int inv2 = qPow(2, MOD - 2);\nconst int inv6 = qPow(6, MOD - 2);\ntemplate&lt;typename T&gt;\ntuple&lt;T, T, T&gt; euclidean(T n, T a, T b, T c){\n    T ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + 1, n21 = n * 2 + 1;\n    if(a == 0){\n        return {\n            bc * n1 % MOD, \n            bc * n % MOD * n1 % MOD * inv2 % MOD,\n            bc * bc % MOD * n1 % MOD\n        };\n    }\n    if(a &gt;= c or b &gt;= c){\n        T f = n * n1 % MOD * inv2 % MOD * ac % MOD + bc * n1 % MOD;\n        T g = ac * n % MOD * n1 % MOD * n21 % MOD * inv6 % MOD + bc * n % MOD * n1 % MOD * inv2 % MOD;\n        T h = ac * ac % MOD * n % MOD * n1 % MOD * n21 % MOD * inv6 % MOD + bc * bc % MOD * n1 % MOD + ac * bc % MOD * n % MOD * n1 % MOD;\n        f %= MOD, g %= MOD, h %= MOD;\n        auto [tf, tg, th] = euclidean(n, a % c, b % c, c);\n        h += th + 2 * bc % MOD * tf % MOD + 2 * ac % MOD * tg % MOD;\n        g += tg;\n        f += tf;\n        return {f % MOD, g % MOD, h % MOD};\n    }\n    auto [tf, tg, th] = euclidean(m - 1, c, c - b - 1, a);\n    T f = (n * m % MOD + MOD - tf) % MOD;\n    T g = (n * m % MOD * n1 % MOD + MOD - th + MOD - tf) % MOD * inv2 % MOD;\n    T h = (n * m % MOD * (m + 1) % MOD + 2 * (MOD - tg) + 2 * (MOD - tf) + MOD - f) % MOD;\n    return {f, g, h};\n}\ntypedef long long ll;\nint main(){\n    int t;\n    cin &gt;&gt; t;\n    while(t--){\n        ll n, a, b, c;\n        cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n        auto [f, g, h] = euclidean(n, a, b, c);\n        cout &lt;&lt; f &lt;&lt; \" \" &lt;&lt; h &lt;&lt; \" \" &lt;&lt; g &lt;&lt; endl;\n    }\n    return 0;\n}\n\n</code></pre>"},{"location":"math/#\u62d3\u5c55\u6b27\u51e0\u91cc\u5f97","title":"\u62d3\u5c55\u6b27\u51e0\u91cc\u5f97","text":"<pre><code>template&lt;typename T&gt;\nT exgcd(T a, T b, T&amp; x, T&amp; y){\n    if(b == 0){\n        x = 1;\n        y = 0;\n        return a;\n    }\n    T d = exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n    return d;\n}\n</code></pre>"},{"location":"math/#\u6b27\u62c9\u51fd\u6570","title":"\u6b27\u62c9\u51fd\u6570","text":""},{"location":"math/#\u5355\u4e2a\u6b27\u62c9\u51fd\u6570","title":"\u5355\u4e2a\u6b27\u62c9\u51fd\u6570","text":"<pre><code>int euler_phi(int n) {\n  int ans = n;\n  for (int i = 2; i * i &lt;= n; i++)\n    if (n % i == 0) {\n      ans = ans / i * (i - 1);\n      while (n % i == 0) n /= i;\n    }\n  if (n &gt; 1) ans = ans / n * (n - 1);\n  return ans;\n}\n</code></pre>"},{"location":"math/#\u6279\u91cf\u6c42\u6b27\u62c9\u51fd\u6570\u7ebf\u6027\u7b5b","title":"\u6279\u91cf\u6c42\u6b27\u62c9\u51fd\u6570\uff08\u7ebf\u6027\u7b5b\uff09","text":"<pre><code>vector&lt;int&gt; eularFunction(int n){\n    vector&lt;int&gt; isPrime(n + 1, 1), phi(n + 1, 0);\n    vector&lt;int&gt; prime;\n    int cnt = 0;\n    isPrime[1] = 0;\n    phi[1] = 1;\n    for(int i = 2; i &lt;= n; ++i){\n        if(isPrime[i]){\n            prime.push_back(i);\n            phi[i] = i - 1;\n        }\n        for(auto it: prime){\n            if(i * it &gt; n) break;\n            isPrime[i * it] = 0;\n            if(i % it){\n                phi[i * it] = phi[i] * phi[it];\n            }else{\n                phi[i * it] = phi[i] * it;\n                break;\n            }\n        }\n    }\n    return phi;\n}\n</code></pre>"},{"location":"math/#\u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570\u7ebf\u6027\u7b5b","title":"\u7b5b\u6cd5\u6c42\u7ea6\u6570\u4e2a\u6570\uff08\u7ebf\u6027\u7b5b\uff09","text":"<pre><code>vector&lt;int&gt; SieveOfEuler(int n){\n    vector&lt;int&gt; ret(n + 1, 0); //\u7ea6\u6570\u4e2a\u6570\n    vector&lt;int&gt; vis(n + 1, 0); //\u662f\u5426\u8bbf\u95ee\u6807\u8bb0\n    vector&lt;int&gt; prime; // \u8d28\u6570\u8868\n    vector&lt;int&gt; num(n + 1, 0); // \u6700\u5c0f\u8d28\u6570\u56e0\u5b50\u51fa\u73b0\u6b21\u6570\n    ret[1] = 1;\n    for(int i = 2; i &lt;= n; ++i){\n        if(!vis[i]){\n            vis[i] = 1;\n            prime.push_back(i);\n            ret[i] = 2;\n            num[i] = 1;\n        }\n        for(auto&amp; it: prime){\n            if(n / it &lt; i) break;\n            vis[it * i] = 1;\n            if(i % it == 0){\n                num[i * it] = num[i] + 1;\n                ret[i * it] = ret[i] / num[i * it] * (num[i * it] + 1);\n                break;\n            }else{\n                num[i * it] = 1;\n                ret[i * it] = ret[i] * 2;\n            }\n        }\n    }\n    return ret;\n}\n</code></pre>"},{"location":"math/#\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406--\u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 &amp; \u6269\u5c55\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406","text":"<pre><code>template&lt;typename T&gt;\nT exgcd(T a, T b, T&amp; x, T&amp; y){\n    if(b == 0){\n        x = 1, y = 0;\n        return a;\n    }\n    T d = exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n    return d;\n}\ntemplate&lt;typename T&gt;\nT mul(T b, T n, T p){\n    T ans = 0;\n    while(n){\n        if(n &amp; 1) ans = (ans + b % p) % p;\n        b = (b + b) % p;\n        n &gt;&gt;= 1;\n    }\n    return ans;\n}\ntemplate&lt;typename T&gt;\nT crt(vector&lt;pair&lt;T, T&gt;&gt;&amp; args){\n    T M = 1, ans = 0, x, y;\n    for(auto&amp; it: args) M *= it.first;\n    for(auto&amp; it: args){\n        T b = M / it.first;\n        exgcd(it.first, b, x, y);\n        y = (y % it.first + it.first) % it.first;\n        ans = (ans + mul(mul(it.second, b, M), y, M)) % M;\n    }\n    return ans;\n}\ntemplate&lt;typename T&gt;\nbool excrt(pair&lt;T, T&gt;&amp; res, vector&lt;pair&lt;T, T&gt;&gt;&amp; args){\n    res = args.front();\n    for(int i = 1; i &lt; args.size(); ++i){\n        T c = (args[i].second - res.second % args[i].first + args[i].first) % args[i].first;   \n        T x, y;\n        T v = exgcd(res.first, args[i].first, x, y);\n        if(c % v) return false;\n        x = mul(x, c / v, args[i].first / v);\n        res.second = (res.second + x * res.first);\n        res.first *= args[i].first / v;\n        res.second = (res.second % res.first + res.first) % res.first;\n    }\n    return true;\n}\n</code></pre>"},{"location":"math/#\u4e58\u6cd5\u9006\u5143","title":"\u4e58\u6cd5\u9006\u5143","text":""},{"location":"math/#\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5","text":"<pre><code>template&lt;typename T&gt;\nT exgcd(T a, T b, T&amp; x, T&amp; y){\n    if(b == 0){\n        x = 1, y = 0;\n        return a;\n    }\n    T d = exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n    return d;\n}\n</code></pre>"},{"location":"math/#\u5feb\u901f\u5e42\u7b97\u6cd5","title":"\u5feb\u901f\u5e42\u7b97\u6cd5","text":"<pre><code>template&lt;typename T&gt;\nT qPow(T b, T n, T p){\n    T res = 1;\n    while(n){\n        if(n &amp; 1) res = res * b % p;\n        b = b * b % p;\n        n &gt;&gt;= 1;\n    }\n    return res;\n}\n</code></pre>"},{"location":"math/#\u6279\u91cf\u4e58\u6cd5\u9006\u5143","title":"\u6279\u91cf\u4e58\u6cd5\u9006\u5143","text":"<p>MOD\u9700\u8981\u662f\u8d28\u6570</p> <pre><code>vector&lt;int&gt; reverse(int n, int MOD){\n    std::vector&lt;int&gt; inv(n + 1, 1);\n    for (int i = 2; i &lt;= n; ++i) {\n        inv[i] = (long long) (MOD - MOD / i) * inv[MOD % i] % MOD;\n    }\n    return inv;\n}\n</code></pre>"},{"location":"math/#\u7ec4\u5408\u6570","title":"\u7ec4\u5408\u6570","text":"<pre><code>template&lt;typename T = int, int P = 1000000007&gt;\nclass Comb{\npublic:\n    Comb(int n): div(n + 1, 1), mul(n + 1, 1){\n        for(int i = 1; i &lt;= n; ++i) mul[i] = 1ll * mul[i - 1] * i % P;\n        div[n] = qPow(mul[n], P - 2);\n        for(int i = n - 1; i &gt; 0; --i) div[i] = 1ll * div[i + 1] * (i + 1) % P;\n    }\n    T operator () (int n, int m){\n        if(m &lt; 0) return 0;\n        if(m &gt; n) return 0;\n        return 1ll * mul[n] * div[m] % P * div[n - m] % P;\n    }\n\nprivate:\n    T qPow(T b, T n){\n        T ret = 1;\n        while(n){\n            if(n &amp; 1) ret = 1ll * ret * b % P;\n            b = 1ll * b * b % P;\n            n &gt;&gt;= 1;\n        }\n        return ret;\n    }\n    vector&lt;T&gt; div, mul;\n};\n</code></pre>"},{"location":"math/#\u5362\u5361\u65af\u5b9a\u7406","title":"\u5362\u5361\u65af\u5b9a\u7406","text":"<p>\u5bf9\u4e8e\u8d28\u6570\\(p\\)\uff0c\u6709 $$     \\binom{n}{m} \\bmod p = \\binom{\\lfloor n / p \\rfloor}{\\lfloor m / p \\rfloor} \\cdot \\binom{\\lfloor n \\bmod p \\rfloor}{\\lfloor m \\bmod p \\rfloor} \\bmod p  $$</p> <pre><code>template&lt;typename T&gt;\nT lucas(T n, T m, T p, const function&lt;T(T, T)&gt;&amp; C){\n    if(m == 0) return 1;\n    T c = C(n % p, m % p);\n    T res = (c * lucas(n / p, m / p, p, C)) % p;\n    return res;\n}\n</code></pre>"},{"location":"math/#bsgs","title":"BSGS","text":"<p>\u5728\\(a\\)\u548c\\(p\\)\u4e92\u8d28\u7684\u60c5\u51b5\u4e0b\uff0c\u6c42\u89e3 $$     a ^ x \\equiv b \\bmod p $$</p> <pre><code>template&lt;typename T&gt;\nT qPow(T b, T n, T p){\n    T ret = 1;\n    while(n){\n        if(n &amp; 1) ret = ret * b % p;\n        b = b * b % p;\n        n &gt;&gt;= 1;\n    }\n    return ret;\n}\ntemplate&lt;typename T&gt;\nT BSGS(T a, T b, T p, T c = 1){\n    map&lt;T, T&gt; mp;\n    T t = (T)sqrt(p) + 1;\n    b %= p;\n    ll tmp = 1;\n    for(int i = 0; i &lt; t; ++i){\n        T tv = b * tmp % p;\n        mp[tv] = i;\n        tmp = (tmp * a) % p;\n    }\n    a = qPow(a, t, p);\n    if(a == 0) return b == 0 ? 1 : -1;\n    for(int i = 0; i &lt;= t; ++i){\n        ll tv = qPow&lt;T&gt;(a, i, p) * c % p;\n        if(mp.count(tv) and i * t - mp[tv] &gt;= 0){\n            return i * t - mp[tv];\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"math/#exbsgs","title":"exBSGS","text":"<p>\u6c42\u89e3 $$     a ^ x \\equiv b \\bmod p $$</p> <pre><code>template&lt;typename T&gt;\nT exgcd(T a, T b, T&amp; x, T&amp; y){\n    if(b == 0){\n        x = 1, y = 0;\n        return a;\n    }\n    T d = exgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n    return d;\n}\ntemplate&lt;typename T&gt;\nT qPow(T b, T n, T p){\n    T ret = 1;\n    while(n){\n        if(n &amp; 1) ret = ret * b % p;\n        b = b * b % p;\n        n &gt;&gt;= 1;\n    }\n    return ret;\n}\ntemplate&lt;typename T&gt;\nT BSGS(T a, T b, T p, T c = 1){\n    map&lt;T, T&gt; mp;\n    T t = (T)sqrt(p) + 1;\n    b %= p;\n    ll tmp = 1;\n    for(int i = 0; i &lt; t; ++i){\n        T tv = b * tmp % p;\n        mp[tv] = i;\n        tmp = (tmp * a) % p;\n    }\n    a = qPow(a, t, p);\n    if(a == 0) return b == 0 ? 1 : -1;\n    for(int i = 0; i &lt;= t; ++i){\n        ll tv = qPow&lt;T&gt;(a, i, p) * c % p;\n        if(mp.count(tv) and i * t - mp[tv] &gt;= 0){\n            return i * t - mp[tv];\n        }\n    }\n    return -1;\n}\ntemplate&lt;typename T&gt;\nT exBSGS(T a, T b, T p){\n    a %= p, b %= p;\n    if(b == 1 or p == 1) return 0;\n    T cnt = 0;\n    T d, ad = 1;\n    T na = 1;\n    while((d = gcd(a, p)) != 1){\n        if(b % d) return -1;\n        ++cnt;\n        b /= d, p /= d;\n        ad = ad * (a / d) % p;\n        if(ad == b) return cnt;\n    }\n    T tx, ty;\n    T dv = exgcd&lt;T&gt;(ad, p, tx, ty);\n    tx = (tx % p + p) % p;\n    T ans = BSGS&lt;T&gt;(a, b * tx % p, p);\n    if(ans &gt;= 0) ans += cnt;\n    return ans;\n}\n</code></pre>"},{"location":"math/#cayley-\u516c\u5f0fcaylays-formula","title":"Cayley \u516c\u5f0f\uff08Caylay's formula\uff09","text":"<p>\u5b8c\u5168\u56fe \\(K_n\\) \u6709 \\(n^{n - 2}\\) \u68f5\u751f\u6210\u6811\u3002</p>"},{"location":"math/#\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u7ebf\u6027\u7b5b","title":"\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\uff08\u7ebf\u6027\u7b5b\uff09","text":"<pre><code>template&lt;int N, typename T = int&gt;\nclass Mu {\npublic:\n    Mu() : muArr(N + 1), pref(N + 1) {\n        bitset&lt;N + 1&gt; notPrime;\n        muArr[1] = 1;\n        for (int i = 2; i &lt;= N; ++i) {\n            if (!notPrime[i]) {\n                prime.push_back(i);\n                muArr[i] = -1;\n            }\n            for (auto it : prime) {\n                if (N / i &gt;= it) {\n                    notPrime[it * i] = 1;\n                    if (i % it == 0) {\n                        break;\n                    } else {\n                        muArr[i * it] = -muArr[i];\n                    }\n                } else {\n                    break;\n                }\n            }\n        }\n        pref[0] = 0;\n        for (int i = 1; i &lt;= N; ++i) {\n            pref[i] = pref[i - 1] + muArr[i];\n        }\n    }\n\n    T&amp; operator[](int i) {\n        return muArr[i];\n    }\n\n    vector&lt;T&gt; pref;\n    vector&lt;T&gt; prime;\nprivate:\n    vector&lt;T&gt; muArr;\n};\n</code></pre>"},{"location":"math/#\u675c\u6559\u7b5b","title":"\u675c\u6559\u7b5b","text":"<pre><code>template&lt;int N = 5000000&gt;\nstruct Du{\n  Du(): vis(N + 1, 0), mu(N + 1, 0), musum(N + 1, 0) {\n    mu[1] = 1;\n    for(int i = 2; i &lt;= N; ++i){\n      if(!vis[i]){\n        pri.push_back(i);\n        mu[i] = -1;\n      }\n      for(auto&amp; it: pri){\n        if(1ll * i * it &gt; N) break;\n        vis[i * it] = 1;\n        if(i % it){\n          mu[i * it] = - mu[i];\n        }else{\n          mu[i * it] = 0;\n          break;\n        }\n      }\n    }\n    for(int i = 1; i &lt;= N; ++i) musum[i] = musum[i - 1] + mu[i];\n  }\n  long long getMuSum(int x){\n    if(x &lt;= N) return musum[x];\n    if(lazyMu.count(x)) return lazyMu[x];\n    long long ret = 1;\n    for(long long i = 2, j; i &lt;= x; i = j + 1){\n      j = x / (x / i);\n      ret -= getMuSum(x / i) * (j - i + 1);\n    }\n    return lazyMu[x] = ret;\n  }\n  long long getPhiSum(int x){\n    long long ret = 0;\n    for(long long i = 1, j; i &lt;= x; i = j + 1){\n      j = x / (x / i);\n      ret += (getMuSum(j) - getMuSum(i - 1)) * (x / i) * (x / i);\n    }\n    return (ret - 1) / 2 + 1;\n  }\n  map&lt;int, long long&gt; lazyMu;\n  vector&lt;int&gt; mu, musum, pri;\n  vector&lt;bool&gt; vis;\n};\n</code></pre>"},{"location":"math/#\u5eb7\u62d3\u5c55\u5f00","title":"\u5eb7\u62d3\u5c55\u5f00","text":""},{"location":"math/#\u6b63\u5411","title":"\u6b63\u5411","text":"<pre><code>/**\n * @brief \u5eb7\u62d3\u5c55\u5f00\n * @param t \u6392\u5217\uff0c\u8fd9\u91cc\u8bbe\u5b9a\u6392\u5217\u7684\u957f\u5ea6\u662f9\n * @return Contar\u503c\n * @author dianhsu\n **/\nint radix[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};\ntemplate&lt;int LEN=9&gt;\nint Contar(int* t){\n    int ret = 0;\n    for(int i = 0; i &lt; LEN; ++i){\n        int tmp = 0;\n        for(int j = i + 1; j &lt; LEN; ++j){\n            if(t[i] &gt; t[j]){\n                ++tmp;\n            }\n        }\n        ret += radix[LEN - 1 - i] * tmp;\n    }\n    return ret;\n}\n</code></pre>"},{"location":"math/#\u53cd\u5411","title":"\u53cd\u5411","text":"<pre><code>/**\n * @brief \u5eb7\u62d3\u5c55\u5f00\u7684\u9006\u8fd0\u7b97\n * @param contar_val Contar \u503c\n * @param t \u8fd4\u56de\u7684Contar\u5e8f\u5217\n * @author dianhsu\n * */\nint radix[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};\ntemplate&lt;int LEN=9&gt;\nvoid ReverseContar(int contar_val, int* t){\n    int vis[LEN];\n    memset(vis, 0, sizeof vis);\n    for(int i = 0; i &lt; LEN; ++i){\n        int idx = contar_val / radix[LEN - 1 - i];\n        contar_val = contar_val % radix[LEN - 1 - i];\n        for(int j = 0; j &lt; LEN; ++j){\n            if(vis[j] == 0){\n                if(idx == 0){\n                    vis[j] = 1;\n                    t[i] = j;\n                    break;\n                }else{\n                    --idx;\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"math/#miller-rabin--pollard-rho","title":"Miller Rabin &amp; Pollard Rho","text":"<pre><code>random_device rd;\nmt19937_64 gen(rd());\nuniform_int_distribution&lt;ll&gt; dis(0);\n\nll qPow(ll b, ll p, ll mod){\n    ll ret = 1;\n    while(p){\n        if(p &amp; 1) ret = (__int128)ret * b % mod;\n        b = (__int128)b * b % mod;\n        p &gt;&gt;= 1;\n    }\n    return ret;\n}\nbool MillerRabin(ll p){\n    if(p &lt; 2) return false;\n    if(p &lt; 4) return true;\n    ll d = p - 1;\n    int r = 0;\n    while((d &amp; 1) == 0) ++r, d &gt;&gt;= 1;\n    for(ll k = 0; k &lt; 10; ++k){\n        ll rv = dis(gen) % (p - 2) + 2;   \n        ll x = qPow(rv, d, p);\n        if(x == 1 or x == p - 1) continue;\n        for(int i = 0; i &lt; r - 1; ++i){\n            x = (__int128) x * x % p;\n            if(x == p - 1) break;\n        }\n        if(x != p - 1) return false;\n    }\n\n    return true;\n}\nll PollardRho(ll n){\n    ll c = rand() % (n - 1) + 1;\n    ll s = 0, t = 0;\n    for(ll goal = 1, val = 1; ; goal *= 2, s = t, val = 1){\n        for(ll step = 1; step &lt;= goal; ++step){\n            t = ((__int128) t * t + c) % n;\n            val = (__int128)val * abs(t - s) % n;\n            if(step % 127 == 0){\n                ll d = gcd(val, n);\n                if(d &gt; 1) return d;\n            }\n        }\n        ll d = gcd(val, n);\n        if(d &gt; 1) return d;\n    }\n}\n\n</code></pre>"},{"location":"math/#\u7ebf\u6027\u4ee3\u6570","title":"\u7ebf\u6027\u4ee3\u6570","text":""},{"location":"math/#\u77e9\u9635","title":"\u77e9\u9635","text":"<p>\u77e9\u9635\u6a21\u677f\uff0c\u642d\u914d\u6a21\u6570\u53ef\u4ee5\u5f53\u6210\u77e9\u9635\u5feb\u901f\u5e42\u3002</p> <pre><code>template&lt;typename T&gt;\nstruct Matrix{\n    std::vector&lt;T&gt; data;\n    int sz;\n    // \u6784\u9020\u51680\u77e9\u9635\uff0c\u6216\u8005\u659c\u5bf9\u89d2\u586b\u4e0a\u81ea\u5b9a\u4e49\u6570\u5b57\n    Matrix(int sz, T v = 0): sz(sz), data(sz * sz, 0){\n        int cur = 0;\n        do{\n            data[cur] = v;\n            cur += sz + 1;\n        }while(cur &lt; sz * sz);\n    }\n    //\u4ecevector\u4e2d\u6784\u9020\u77e9\u9635\n    Matrix(int sz, std::vector&lt;T&gt;&amp; arg): sz(sz), data(sz * sz, 0){\n        assert(arg.size() &gt;= sz * sz);\n        for(int i = 0; i &lt; sz * sz; ++i) data[i] = arg[i];\n    }\n    //\u4ecevector\u4e2d\u6784\u9020\u77e9\u9635\uff0c\u53f3\u503c\n    Matrix(int sz, std::vector&lt;T&gt;&amp;&amp; arg): sz(sz), data(sz * sz, 0){\n        assert(arg.size() &gt;= sz * sz);\n        for(int i = 0; i &lt; sz * sz; ++i) data[i] = arg[i];\n    }\n    Matrix operator + (const Matrix&amp; arg) const {\n        assert(sz == arg.sz);\n        Matrix ret(sz);\n        for(int i = 0; i &lt; sz * sz; ++i){\n            ret.data[i] = data[i] + arg.data[i];\n        }\n        return ret;\n    }\n    Matrix operator * (const Matrix&amp; arg) const {\n        assert(sz == arg.sz);\n        Matrix ret(sz);\n        for(int i = 0; i &lt; sz; ++i){\n            for(int j = 0; j &lt; sz; ++j){\n                for(int k = 0; k &lt; sz; ++k){\n                    ret.data[i * sz + j] += data[i * sz + k] * arg.data[k * sz + j];\n                }\n            }\n        }\n        return ret;\n    }\n    Matrix operator - (const Matrix&amp; arg) const {\n        assert(sz == arg.sz);\n        Matrix ret(sz);\n        for(int i = 0; i &lt; sz * sz; ++i) ret.data[i] = data[i] - arg.data[i];\n        return ret;\n    }\n    friend std::ostream &amp; operator &lt;&lt; (std::ostream&amp; ots, const Matrix&amp; arg){\n        for(int i = 0; i &lt; arg.sz; ++i){\n            for(int j = 0; j &lt; arg.sz; ++j){\n                if(j) ots &lt;&lt; \" \";\n                ots &lt;&lt; arg.data[i * arg.sz + j];\n            }\n            if(i + 1 != arg.sz) ots &lt;&lt; \"\\n\";\n        }\n        return ots;\n    }\n};\n</code></pre>"},{"location":"math/#\u9ad8\u65af\u6d88\u5143","title":"\u9ad8\u65af\u6d88\u5143","text":"<pre><code>template&lt;typename T&gt;\nstruct Gauss{\n    Gauss(int argR, int argC): r(argR), c(argC), mat(r, vector&lt;T&gt;(c, 0)), idx(r, 0){\n        assert(argC &gt;= argR);\n        iota(idx.begin(), idx.end(), 0);\n    }\n    T&amp; operator () (int row, int col){\n        return mat[row][col];\n    }\n    int r, c;\n    friend istream&amp; operator &gt;&gt; (istream&amp; its, Gauss&amp; arg){\n        for(int i = 0; i &lt; arg.r; ++i){\n            for(int j = 0; j &lt; arg.c; ++j){\n                its &gt;&gt; arg(i, j);\n            }\n        }\n        return its;\n    }\n    friend ostream&amp; operator &lt;&lt; (ostream&amp; ots, Gauss&amp; arg){\n        for(int i = 0; i &lt; arg.r; ++i){\n            for(int j = 0; j &lt; arg.c; ++j){\n                ots &lt;&lt; arg(arg.idx[i], j);\n                if(j + 1 != arg.c) ots &lt;&lt; \" \";\n            }\n            if(i + 1 != arg.r) ots &lt;&lt; \"\\n\";\n        }\n        return ots;\n    }\n    vector&lt;vector&lt;T&gt;&gt; mat;\n    vector&lt;int&gt; idx;\n    bool elimination(const function&lt;bool(T)&gt;&amp; isZero, const function&lt;T(T)&gt;&amp; inv){\n        for(int i = 0; i &lt; r; ++i){\n            int cur = i;\n            for(int j = i + 1; j &lt; r; ++j){\n                if(abs(mat[idx[j]][i]) &gt; abs(mat[idx[cur]][i])){\n                    cur = j;\n                }\n            }\n            swap(idx[i], idx[cur]);\n            if(isZero(mat[idx[i]][i])) return false;\n            T mul = inv(mat[idx[i]][i]);\n            for(int j = i; j &lt; c; ++j){\n                mat[idx[i]][j] *= mul;\n            }\n            for(int i1 = 0; i1 &lt; r; ++i1){\n                if(i1 == i) continue;\n                T cmul = mat[idx[i1]][i];\n                for(int j = i; j &lt; c; ++j){\n                    mat[idx[i1]][j] -= mat[idx[i]][j] * cmul;\n                }\n            }\n        }\n        return true;\n    }\n};\n</code></pre>"},{"location":"math/#\u7ebf\u6027\u57fa","title":"\u7ebf\u6027\u57fa","text":"<pre><code>struct LBase{\n  vector&lt;long long&gt; _data;\n  LBase(): _data(64, 0){}\n  bool insert(long long x){\n    for(int i = 63 - __builtin_clzll(x); i &gt;= 0; --i){\n      if((x &gt;&gt; i) &amp; 1){\n        if(_data[i]) x ^= _data[i];\n        else{\n          _data[i] = x;\n          break;\n        }\n      }\n    }\n    return x &gt; 0;\n  }\n  LBase&amp; operator += (const LBase&amp; arg){\n    for(auto ptr = arg._data.rbegin(); ptr != arg._data.rend(); ++ptr){\n      this-&gt;insert(*ptr);\n    }\n    return *this;\n  }\n  long long query(){\n    long long ret = 0;\n    for(auto ptr = _data.rbegin(); ptr != _data.rend(); ++ptr){\n      if(*ptr){\n        if((ret ^ (*ptr)) &gt; ret) ret ^= *ptr;\n      }\n    }\n    return ret;\n  }\n  int count(){\n    int ret = 0;\n    for(auto&amp; it: _data) if(it) ++ret;\n    return ret;\n  }\n};\n</code></pre>"},{"location":"math/#\u81ea\u9002\u5e94\u8f9b\u666e\u68ee","title":"\u81ea\u9002\u5e94\u8f9b\u666e\u68ee","text":"<pre><code>template&lt;typename T&gt;\nT simpson(T l, T r, const function&lt;T(T)&gt;&amp; f){\n  T mid = (l + r) / 2;\n  return (r - l) * (f(l) + 4 * f(mid) + f(r)) / 6;\n}\n\ntemplate&lt;typename T&gt;\nT asr(T l, T r, T delta, T ans, int step, const function&lt;T(T)&gt;&amp; f){\n  T mid = (l + r) / 2;\n  T fl = simpson&lt;T&gt;(l, mid, f), fr = simpson&lt;T&gt;(mid, r, f);\n  if(abs(fl + fr - ans) &lt;= 15 * delta and step &lt; 0){\n    return fl + fr + (fl + fr - ans) / 15;\n  }\n  return asr(l, mid, delta / 2, fl, step - 1, f) + asr(mid, r, delta / 2, fr, step - 1, f);\n}\ntemplate&lt;typename T = double&gt;\nT adaptiveSimpson(T l, T r, T delta, const function&lt;T(T)&gt;&amp; f){\n  return asr&lt;T&gt;(l, r, delta, simpson&lt;T&gt;(l, r, f), 12, f);\n}\n</code></pre>"},{"location":"math/#\u591a\u9879\u5f0f","title":"\u591a\u9879\u5f0f","text":""},{"location":"math/#\u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362","title":"\u5feb\u901f\u5085\u7acb\u53f6\u53d8\u6362","text":"<pre><code>template&lt;typename T&gt;\nvoid butterflyDiagram(vector&lt;complex&lt;T&gt;&gt;&amp; vec){\n    assert(__builtin_popcount(vec.size()) == 1);\n    vector&lt;int&gt; rev(vec.size());\n    for(int i = 0; i &lt; vec.size(); ++i){\n        rev[i] = rev[i &gt;&gt; 1] &gt;&gt; 1;\n        if(i &amp; 1){\n            rev[i] |= (vec.size() &gt;&gt; 1);\n        }\n    }\n    for(int i = 0; i &lt; vec.size(); ++i){\n        if(i &lt; rev[i]){\n            swap(vec[i], vec[rev[i]]);\n        }\n    }\n}\n// on == 1 \u65f6\u662f DFT\uff0con == -1 \u65f6\u662f IDFT\ntemplate&lt;typename T&gt;\nvoid fft(vector&lt;complex&lt;T&gt;&gt;&amp; vec, int on){\n    assert(__builtin_popcount(vec.size()) == 1);\n    butterflyDiagram(vec);\n    for(int h = 1; h &lt; vec.size(); h &lt;&lt;= 1){\n        complex&lt;T&gt; wn(cos(M_PI / h), sin(on * M_PI / h));\n        for(int j = 0; j &lt; vec.size(); j += h * 2){\n            complex&lt;T&gt; w(1, 0);\n            for(int k = j; k &lt; j + h; ++k){\n                assert(k &lt; vec.size() and h + k &lt; vec.size());\n                auto u = vec[k];\n                auto t = w * vec[k + h];\n                vec[k] = u + t;\n                vec[k + h] = u - t;\n                w *= wn;\n            }\n        }\n    }\n    if(on == -1){\n        for(auto&amp; it: vec){\n            it.real(it.real() / vec.size());\n        }\n    }\n}\n</code></pre>"},{"location":"miscellaneous/","title":"\u6742\u9879","text":""},{"location":"miscellaneous/#fast-io","title":"Fast I/O","text":"<pre><code>template&lt;typename T = int&gt;\ninline T fRead() {\n    T x = 0, w = 1; char c = getchar();\n    while (c &lt; '0' || c&gt;'9') { if (c == '-') w = -1; c = getchar(); }\n    while (c &lt;= '9' &amp;&amp; c &gt;= '0') { x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0'; c = getchar(); }\n    return w == 1 ? x : -x;\n}\ntemplate&lt;typename T = int&gt;\ninline T cRead() {\n    T ret;\n    cin &gt;&gt; ret;\n    return ret;\n}\ntemplate&lt;typename T = int&gt;\ninline void fWrite(T x){\n    if(x &lt; 0){\n        x = -x;\n        putchar('-');\n    }\n    if(x &gt;= 10) fWrite(x / 10);\n    putchar(x % 10 + '0');\n}\ntemplate&lt;typename T = int&gt;\ninline void cWrite(T x){\n    cout &lt;&lt; x;\n}\n</code></pre>"},{"location":"miscellaneous/#y-combinator","title":"Y combinator","text":"<pre><code>template&lt;class Fun&gt;\nclass Y_combinator {\nprivate:\n    Fun fun_;\npublic:\n    template&lt;class F&gt;\n    Y_combinator(F&amp;&amp; fun) : fun_(static_cast&lt;F&amp;&amp;&gt;(fun)) {}\n    template&lt;class... Args&gt;\n    decltype(auto) operator () (Args&amp;&amp;...args) const {\n        return fun_(*this, static_cast&lt;Args&amp;&amp;&gt;(args)...);\n    }\n};\ntemplate&lt;class T&gt; Y_combinator(T)-&gt;Y_combinator&lt;T&gt;;\n</code></pre>"},{"location":"miscellaneous/#numeric-binary-search","title":"Numeric Binary Search","text":"<pre><code>int lower_bound(int target, vector&lt;int&gt;&amp; vec){\n    int pos = -1;\n    for(int i = (32 - __builtin_clz(vec.size())); i; i &gt;&gt;= 1){\n        if(pos + i &lt; vec.size() and vec[pos + i] &lt; target){\n            pos += i;\n        }\n    }\n    return pos + 1;\n}\n</code></pre>"},{"location":"miscellaneous/#least-power-of-2-and-greater-power-of-2","title":"Least Power of 2 and Greater Power of 2","text":"<pre><code>int leastPowerOfTwo(int val){\n    return 32 - __builtin_clz(val - 1);\n}\nint greaterPowerOfTwo(int val){\n    return 32 - __builtin_clz(val);\n}\n</code></pre>"},{"location":"string/","title":"\u5b57\u7b26\u4e32","text":""},{"location":"string/#kmp","title":"KMP","text":"<pre><code>template&lt;typename RandomAccessIterator&gt;\nvector&lt;int&gt; preKmp(RandomAccessIterator pBegin, RandomAccessIterator pEnd, bool accelerate = false){\n    vector&lt;int&gt; fall(distance(pBegin, pEnd) + 1, -1);\n    int i = 0, j = -1;\n    while(i + pBegin != pEnd){\n        while(j != -1 and *(pBegin + i) != *(pBegin + j)) j = fall[j];\n        ++i, ++j;\n        if(accelerate){\n             // \u8fd9\u91cc\u7684\u4f18\u5316\uff0c\u5982\u679c\u4e00\u76f4\u4e0d\u5339\u914d\u4f1a\u5f97\u5230 fall[fall[...fall[i]...]]\n             if(i &lt; distance(pBegin, pEnd) and j &lt; distance(pBegin, pEnd) and *(pBegin + i) == *(pBegin + j)) fall[i] = fall[j];\n             else fall[i] = j;\n        }else{\n            fall[i] = j;\n        }\n    }\n    return fall;\n}\ntemplate&lt;typename RandomAccessIterator&gt;\nint kmp(RandomAccessIterator tBegin, RandomAccessIterator tEnd, RandomAccessIterator pBegin, RandomAccessIterator pEnd, vector&lt;int&gt;&amp; fall){\n    int i = 0, j = 0;\n    int ans = 0;\n    while(tBegin + i &lt; tEnd){\n        while(j != -1 and *(pBegin + j) != *(tBegin + i)) j = fall[j];\n        ++i, ++j;\n        if(j &gt;= distance(pBegin, pEnd)){\n            ++ans;\n            cout &lt;&lt; i - distance(pBegin, pEnd) + 1 &lt;&lt; \"\\n\";\n            j = fall[j];\n        }\n    }\n    return ans;\n}\ntemplate&lt;typename RandomAccessIterator&gt;\nint kmp(RandomAccessIterator tBegin, RandomAccessIterator tEnd, RandomAccessIterator pBegin, RandomAccessIterator pEnd, bool accelerate = false){\n    auto&amp;&amp; fall = preKmp(pBegin, pEnd, accelerate);\n    return kmp(tBegin, tEnd, pBegin, pEnd, fall);\n}\n</code></pre>"},{"location":"string/#z-function\u62d3\u5c55kmp","title":"Z Function\uff08\u62d3\u5c55KMP\uff09","text":"<pre><code>template&lt;typename RandomAccessIterator&gt;\nvector&lt;int&gt; zFunction(RandomAccessIterator pBegin, RandomAccessIterator pEnd){\n    int n = distance(pBegin, pEnd);\n    vector&lt;int&gt; z(n);\n    for(int i = 1, l = 0, r = 0; i &lt; n; ++i){\n        if(i &lt;= r and z[i - l] &lt; r - i + 1){\n            z[i] = z[i - l];\n        }else{\n            z[i] = max(0, r - i + 1);\n            while(i + z[i] &lt; n and *(pBegin + z[i]) == *(pBegin + i + z[i])) ++z[i];\n        }\n        if(i + z[i] - 1 &gt; r){\n            l = i;\n            r = i + z[i] - 1;\n        }\n    }\n    return z;\n}\n</code></pre>"},{"location":"string/#manacher","title":"Manacher","text":"<pre><code>enum Separator {\n    Start,\n    Mid,\n    End\n};\n\ntemplate&lt;typename RandomAccessIterator&gt;\npair&lt;RandomAccessIterator, RandomAccessIterator&gt; manacher(RandomAccessIterator sBegin, RandomAccessIterator sEnd) {\n    vector&lt;any&gt; ma;\n    ma.reserve(distance(sBegin, sEnd) * 2 + 10);\n    ma.emplace_back(Start);\n    ma.emplace_back(Mid);\n    for (auto ptr = sBegin; ptr != sEnd; ++ptr) {\n        ma.push_back(ptr);\n        ma.emplace_back(Mid);\n    }\n    ma.emplace_back(End);\n    int len = (int)ma.size();\n    vector&lt;int&gt; mp(len, 0);\n    int mx = 0, id = 0;\n    int maxPos = 0;\n    for (int i = 1; i &lt; len - 1; ++i) {\n        mp[i] = mx &gt; i ? std::min(mp[(id &lt;&lt; 1) - i], mx - i) : 1;\n        while (ma[i + mp[i]].type() == ma[i - mp[i]].type() and\n               (ma[i + mp[i]].type() == typeid(RandomAccessIterator) ?\n                (*any_cast&lt;RandomAccessIterator&gt;(ma[i + mp[i]]) ==\n                 *any_cast&lt;RandomAccessIterator&gt;(ma[i - mp[i]])) :\n                (any_cast&lt;Separator&gt;(ma[i + mp[i]])) ==\n                any_cast&lt;Separator&gt;(ma[i - mp[i]]))) {\n            ++mp[i];\n        }\n        if(mp[i] &gt; mp[maxPos]) maxPos = i;\n        if(i + mp[i] &gt; mx){\n            mx = i + mp[i];\n            id = i;\n        }\n    }\n    pair&lt;RandomAccessIterator, RandomAccessIterator&gt; ret;\n    int l = maxPos - mp[maxPos] + 1, r = maxPos + mp[maxPos] - 1;\n    if(l &amp; 1) ++l;\n    if(r &amp; 1) --r;\n    return {sBegin + (l - 1) / 2, sBegin + (r + 1) / 2};\n}\n</code></pre>"},{"location":"string/#\u5b57\u7b26\u4e32\u54c8\u5e0c","title":"\u5b57\u7b26\u4e32\u54c8\u5e0c","text":"<pre><code>\nnamespace string_hash{\nunsigned BKDR(const std::string&amp; str){\n    unsigned seed = 131; // 31 131 1313 13131 131313 etc..\n    unsigned hash = 0;\n    for(auto c: str){\n        hash = hash * seed + c;\n    }\n    return (hash &amp; 0x7FFFFFFF);\n}\nunsigned AP(const std::string&amp; str){\n    unsigned hash = 0;\n    for(int i = 0; i &lt; str.length(); ++i){\n        if(i &amp; 1){\n            hash ^= (~((hash &lt;&lt; 11) ^ str[i] ^ (hash &gt;&gt; 5)));\n        }else{\n            hash ^= ((hash &lt;&lt; 7) ^ str[i] ^ (hash &gt;&gt; 3));\n        }\n    }\n    return (hash &amp; 0x7FFFFFFF);\n}\nunsigned DJB(const std::string&amp; str){\n    unsigned hash = 5381;\n    for(auto c: str){\n        hash += (hash &lt;&lt; 5) + c;\n    }\n    return (hash &amp; 0x7FFFFFFF);\n}\nunsigned JS(const std::string&amp; str){\n    unsigned hash = 1315423911;\n    for(auto c: str) hash ^= ((hash &lt;&lt; 5) + c + (hash &gt;&gt; 2));\n    return (hash &amp; 0x7FFFFFFF);\n}\nunsigned SDBM(const std::string&amp; str){\n    unsigned hash = 0;\n    for(auto c: str) hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;\n    return (hash &amp; 0x7FFFFFFF);\n}\nunsigned PJW(const std::string&amp; str){\n    auto bits_in_unsigned_int = (unsigned)(sizeof(unsigned) * 8);\n    auto three_quarters = (unsigned)(bits_in_unsigned_int * 3 / 4);\n    auto one_eighth = (unsigned)(bits_in_unsigned_int / 8);\n    unsigned high_bits = (unsigned)(0xFFFFFFFF) &lt;&lt; (bits_in_unsigned_int - one_eighth);\n    unsigned hash = 0;\n    unsigned test = 0;\n    for(auto c: str){\n        hash = (hash &lt;&lt; one_eighth) + c;\n        if((test = hash &amp; high_bits) != 0){\n            hash = (hash ^ (test &gt;&gt; three_quarters)) &amp; (~high_bits);\n        }\n    }\n    return (hash &amp; 0x7FFFFFFF);\n}\nunsigned ELF(const std::string&amp; str){\n    unsigned hash = 0, x = 0;\n    for(auto c: str){\n        hash = (hash &lt;&lt; 4) + c;\n        if((x = hash &amp; 0xF0000000ll) != 0){\n            hash ^= (x &gt;&gt; 24);\n            hash &amp;= (~x);\n        }\n    }\n    return (hash &amp; 0x7FFFFFFF);\n}\n}\n</code></pre>"},{"location":"string/#ac-\u81ea\u52a8\u673a","title":"AC \u81ea\u52a8\u673a","text":"<pre><code>\nnamespace ac_automaton{\ntemplate&lt;int CHILD_CNT=26&gt;\nstruct Node{\n    int cnt;\n    vector&lt;shared_ptr&lt;Node&gt;&gt; next;\n    weak_ptr&lt;Node&gt; fail;\n    explicit Node(shared_ptr&lt;Node&gt; root = nullptr): cnt(0), next(CHILD_CNT, root), fail(root){}\n};\ntemplate&lt;typename Iterator, int CHILD_CNT=26&gt;\nclass AC{\n    using T = typename remove_reference&lt;decltype(*declval&lt;Iterator&gt;())&gt;::type;\n    using ACNode = Node&lt;CHILD_CNT&gt;;\npublic:\n    explicit AC(): root(shared_ptr&lt;ACNode&gt;(new ACNode())){\n        root-&gt;fail = root;\n        for(auto&amp; nex: root-&gt;next){\n            nex = root;\n        }\n    }\n    void insert(Iterator sBegin, Iterator sEnd, function&lt;int(T)&gt; func){\n        auto ptr = root;\n        for(Iterator sPtr = sBegin; sPtr != sEnd; ++sPtr){\n            int to = func(*sPtr);\n            if(ptr-&gt;next[to] == root){\n                ptr-&gt;next[to] = shared_ptr&lt;ACNode&gt;(new ACNode(root));\n            }\n            ptr = ptr-&gt;next[to];\n        }\n        ptr-&gt;cnt++;\n    }\n    void build(){\n        queue&lt;shared_ptr&lt;ACNode&gt;&gt; Q;\n        for(int i = 0; i &lt; CHILD_CNT; ++i){\n            if(root-&gt;next[i] != root){\n                Q.push(root-&gt;next[i]);\n            }\n        }\n        while(!Q.empty()){\n            auto ptr = Q.front();\n            Q.pop();\n            for(int i = 0; i &lt; CHILD_CNT; ++i){\n                if(ptr-&gt;next[i] != root){\n                    ptr-&gt;next[i]-&gt;fail = ptr-&gt;fail.lock()-&gt;next[i];\n                    Q.push(ptr-&gt;next[i]);\n                }else{\n                    ptr-&gt;next[i] = ptr-&gt;fail.lock()-&gt;next[i];\n                }\n            }\n        }\n    }\n    int query(Iterator qBegin, Iterator qEnd, function&lt;int(T)&gt; func){\n       int ans = 0;\n       auto ptr = root;\n       for(auto qPtr = qBegin; qPtr != qEnd; ++qPtr){\n           ptr = ptr-&gt;next[func(*qPtr)];\n           for(auto tPtr = ptr; tPtr != root and tPtr-&gt;cnt != -1; tPtr = tPtr-&gt;fail.lock()){\n               ans += tPtr-&gt;cnt;\n               tPtr-&gt;cnt = -1;\n           }\n       }\n       return ans;\n    }\nprivate:\n    shared_ptr&lt;ACNode&gt; root;\n};\n}\n</code></pre>"}]}